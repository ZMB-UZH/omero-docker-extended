#!/usr/bin/env bash\n\n# Cleanup helper for build-time-only containers/images.\n# Must be run as root on the host.\n\nset -euo pipefail\n\nSCRIPT_NAME=\"$(basename \"$0\")\"\n\n# For backward compatibility; we remove this builder if it exists.\nDOCKER_BUILDX_BUILDER_NAME=\"${DOCKER_BUILDX_BUILDER_NAME:-omero-builder}\"\n\n# Containers we want completely gone after installation finishes.\nFIXED_CONTAINERS=(\n  \"redis-sysctl-init\"\n)\n\n# Images to remove after installation, even if the container is already gone.\n# These are one-shot images that serve no purpose after the init phase.\nFIXED_IMAGES=(\n  \"redis-sysctl-init:custom\"\n)\n\nrequire_root() {\n  if [ \"$(id -u)\" -ne 0 ]; then\n    echo \"ERROR (${SCRIPT_NAME}): Must run as root.\" >&2\n    exit 1\n  fi\n}\n\ncontainer_exists() {\n  local name=\"$1\"\n  docker container inspect \"${name}\" >/dev/null 2>&1\n}\n\ncontainer_state() {\n  local name=\"$1\"\n  docker container inspect -f '{{.State.Status}}' \"${name}\" 2>/dev/null || true\n}\n\nstop_container_best_effort() {\n  local name=\"$1\"\n  container_exists \"${name}\" || return 0\n  docker stop -t 20 \"${name}\" >/dev/null 2>&1 || true\n}\n\nwait_container_stopped() {\n  local name=\"$1\"\n  local timeout_seconds=\"${2:-30}\"\n  local waited=0\n\n  while container_exists \"${name}\"; do\n    local st\n    st=\"$(container_state \"${name}\")\"\n    case \"${st}\" in\n      exited|dead|created|\"\")\n        return 0\n        ;;\n      running|restarting|paused)\n        ;;\n      *)\n        ;;\n    esac\n\n    if [ \"${waited}\" -ge \"${timeout_seconds}\" ]; then\n      echo \"WARNING (${SCRIPT_NAME}): Timeout waiting for ${name} to stop (state=${st}).\" >&2\n      return 1\n    fi\n\n    sleep 1\n    waited=$((waited + 1))\n  done\n\n  return 0\n}\n\nremove_container_force() {\n  local name=\"$1\"\n  container_exists \"${name}\" || return 0\n  docker rm -f \"${name}\" >/dev/null 2>&1 || true\n}\n\ndiscover_container_image_id() {\n  local name=\"$1\"\n  docker container inspect -f '{{.Image}}' \"${name}\" 2>/dev/null || true\n}\n\ndiscover_container_volume_names() {\n  local name=\"$1\"\n  docker container inspect -f '{{range .Mounts}}{{if eq .Type \"volume\"}}{{.Name}}{{\"\\n\"}}{{end}}{{end}}' \"${name}\" 2>/dev/null || true\n}\n\nremove_image_force() {\n  local image_ref=\"$1\"\n  [ -z \"${image_ref}\" ] && return 0\n  docker rmi -f \"${image_ref}\" >/dev/null 2>&1 || true\n}\n\nremove_volume_force() {\n  local volume_name=\"$1\"\n  [ -z \"${volume_name}\" ] && return 0\n  docker volume rm -f \"${volume_name}\" >/dev/null 2>&1 || true\n}\n\ncleanup_one_container() {\n  local name=\"$1\"\n\n  container_exists \"${name}\" || return 0\n\n  local image_id=\"\"\n  image_id=\"$(discover_container_image_id \"${name}\")\"\n\n  local volumes\n  volumes=\"$(discover_container_volume_names \"${name}\")\"\n\n  echo \"Cleaning container: ${name}\"\n  stop_container_best_effort \"${name}\"\n  wait_container_stopped \"${name}\" 30 || true\n  remove_container_force \"${name}\"\n\n  if [ -n \"${volumes}\" ]; then\n    while IFS= read -r v; do\n      [ -z \"${v}\" ] && continue\n      echo \"Removing docker volume: ${v} (from ${name})\"\n      remove_volume_force \"${v}\"\n    done <<< \"${volumes}\"\n  fi\n\n  if [ -n \"${image_id}\" ]; then\n    echo \"Removing docker image id: ${image_id} (from ${name})\"\n    remove_image_force \"${image_id}\"\n  fi\n}\n\ncleanup_buildx_builder() {\n  local builder_name=\"$1\"\n\n  # Discover buildkit images BEFORE removing the builder container\n  # (Since docker buildx rm destroys the container, we'd lose the image reference otherwise)\n  local buildkit_images=\"\"\n  buildkit_images=\"$(docker ps -a --filter \"name=buildx_buildkit_${builder_name}\" --format '{{.Image}}' 2>/dev/null || true)\"\n\n  # Discover anonymous volumes attached to the builder container BEFORE removing it\n  local buildkit_volumes=\"\"\n  buildkit_volumes=\"$(docker ps -a --filter \"name=buildx_buildkit_${builder_name}\" --format '{{.Names}}' 2>/dev/null | xargs -I {} docker container inspect -f '{{range .Mounts}}{{if eq .Type \"volume\"}}{{.Name}}{{\"\\n\"}}{{end}}{{end}}' {} 2>/dev/null || true)\"\n\n  # Remove the named builder if present.\n  if docker buildx inspect \"${builder_name}\" >/dev/null 2>&1; then\n    echo \"Removing buildx builder: ${builder_name}\"\n    docker buildx rm \"${builder_name}\" >/dev/null 2>&1 || true\n  fi\n\n  # Remove ANY remaining buildx buildkit container (covers default builder, old builders,\n  # and containers that created anonymous volumes).\n  local c\n  while IFS= read -r c; do\n    [ -z \"${c}\" ] && continue\n    cleanup_one_container \"${c}\"\n  done < <(docker ps -a --format '{{.Names}}' 2>/dev/null | grep -E '^buildx_buildkit_.*' || true)\n\n  # Remove any remaining buildx volumes by name (best effort).\n  local v\n  while IFS= read -r v; do\n    [ -z \"${v}\" ] && continue\n    echo \"Removing buildx named volume: ${v}\"\n    remove_volume_force \"${v}\"\n  done < <(docker volume ls -q 2>/dev/null | grep -E '^buildx_buildkit_.*' || true)\n\n  # Remove discovered anonymous volumes from the named builder\n  if [ -n \"${buildkit_volumes}\" ]; then\n    while IFS= read -r v; do\n      [ -z \"${v}\" ] && continue\n      echo \"Removing buildx anonymous volume: ${v}\"\n      remove_volume_force \"${v}\"\n    done <<< \"${buildkit_volumes}\"\n  fi\n\n  # Remove discovered buildkit images from the named builder\n  if [ -n \"${buildkit_images}\" ]; then\n    local img\n    while IFS= read -r img; do\n      [ -z \"${img}\" ] && continue\n      echo \"Removing buildx image: ${img}\"\n      remove_image_force \"${img}\"\n    done <<< \"${buildkit_images}\"\n  fi\n\n  # Fallback: aggressively remove ALL moby/buildkit images to prevent orphaned images\n  # (Buildx creates dynamic tags like moby/buildkit:buildx-stable-1)\n  local dangling_buildkit\n  dangling_buildkit=\"$(docker images --format '{{.Repository}}:{{.Tag}}' 2>/dev/null | grep '^moby/buildkit' || true)\"\n  if [ -n \"${dangling_buildkit}\" ]; then\n    local img\n    while IFS= read -r img; do\n      [ -z \"${img}\" ] && continue\n      echo \"Removing fallback buildx image: ${img}\"\n      remove_image_force \"${img}\"\n    done <<< \"${dangling_buildkit}\"\n  fi\n}\n\ncleanup_probe_containers() {\n  echo \"Cleaning up probe containers...\"\n  local c\n  while IFS= read -r c; do\n    [ -z \"${c}\" ] && continue\n    echo \"Removing stuck probe container: ${c}\"\n    remove_container_force \"${c}\"\n  done < <(docker ps -a --format '{{.Names}}' 2>/dev/null | grep -E '^omero-install-probe-' || true)\n}\n\nmain() {\n  require_root\n\n  cleanup_buildx_builder \"${DOCKER_BUILDX_BUILDER_NAME}\"\n  cleanup_probe_containers\n\n  local name\n  for name in \"${FIXED_CONTAINERS[@]}\"; do\n    cleanup_one_container \"${name}\"\n  done\n\n  # Remove one-shot images that may linger after the container is already gone.\n  local image_name\n  for image_name in \"${FIXED_IMAGES[@]}\"; do\n    if docker image inspect \"${image_name}\" >/dev/null 2>&1; then\n      echo \"Removing one-shot image: ${image_name}\"\n      remove_image_force \"${image_name}\"\n    fi\n  done\n\n  # Remove dangling image objects left behind by interrupted/replaced builds.\n  # This prevents <none>:<none> images from persisting in container UIs.\n  docker image prune -f >/dev/null 2>&1 || true\n\n  echo \"Cleanup complete.\"\n}\n\nmain \"$@\"\n