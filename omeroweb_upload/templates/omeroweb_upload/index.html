{% load static %}
<!DOCTYPE html>
<html lang="en" data-user-id="{{ user_id|default:"" }}">
<head>
    <meta charset="UTF-8">
    <title>Upload</title>
    <link rel="stylesheet" href="{% static 'omeroweb_upload/styles.css' %}">
    <script src="{% static 'omeroweb_upload/upload.js' %}" defer></script>
</head>
<body>
    <div class="root-user-overlay" aria-hidden="true"></div>
    <div id="root-user-warning" class="root-user-warning" role="alert">
        PLEASE LOGIN AS REGULAR USER<br>
        TO USE THIS PLUGIN
    </div>
    <div class="upload-page">
        <h1 class="upload-title">Upload</h1>
        <p class="upload-intro">Drag & drop or choose folders and files to upload and import them into your user space in OMERO. Selecting a project is suggested.</p>
        <p class="upload-intro">All orphan files in base path will be imported into a dataset named "Orphaned_images_base_path_import" with a random suffix.</p>
        <p class="upload-intro">Folder names are translated into dataset names. Nested folders become datasets named with backslashes (e.g. <code>folderA\subfolderB</code>).</p>
        <div class="upload-utilities">
            <div class="upload-utilities__center">
                <div class="upload-utilities__collaboration">
                    <input type="checkbox" id="collaboration_toggle">
                    <label for="collaboration_toggle">Collaboration</label>
                </div>
                <div class="upload-utilities__compatibility">
                    <input type="checkbox" id="compatibility_toggle">
                    <label for="compatibility_toggle">Compatibility check</label>
                </div>
            </div>
            <div class="upload-utilities__actions">
                <button type="button"
                        id="settings_menu_btn"
                        class="gear-btn"
                        title="Settings"
                        aria-label="Settings">
                    ⚙
                </button>
                <a href="{% url 'omeroweb_upload_help' %}"
                   target="_blank"
                   rel="noopener noreferrer"
                   title="Help"
                   aria-label="Help"
                   class="help-btn">
                    ?
                </a>
                <div id="settings_menu"
                     class="settings-menu"
                     style="display:none;">
                    <button type="button"
                            id="user_settings_btn"
                            class="settings-menu-item">
                        User settings
                    </button>
                </div>
            </div>
        </div>
        <div id="upload-card" class="upload-card" data-start-url="{{ upload_start_url }}">
            <div class="upload-card__overlay" aria-live="polite">Uploading</div>
            <div class="upload-card__content">
                <div class="upload-intro-row">
                    <p id="upload_intro_text"><strong>Drag & drop</strong> folders and files here or <strong>choose from storage</strong>.</p>
                    <div class="project-select-wrapper" id="special_upload_wrapper">
                        <input type="text"
                               id="special_upload_input"
                               placeholder="Select a special method..."
                               autocomplete="off"
                               class="project-select-input">
                        <div id="special_upload_display" class="project-select-display" aria-hidden="true"></div>
                        <span class="project-select-arrow" aria-hidden="true">▾</span>
                        <input type="hidden" id="special_upload" value="">
                        <div id="special_upload_dropdown"
                             style="display:none; 
                                    position:absolute; 
                                    left:-1px; 
                                    top:100%;
                                    background:#fff; 
                                    border:1px solid #007bff; 
                                    border-top:none;
                                    max-height:530px; 
                                    overflow:visible; 
                                    z-index:1100; 
                                    border-radius:0 0 6px 6px;
                                    width:calc(100% + 2px); 
                                    box-sizing:border-box;">
                        </div>
                    </div>
                </div>
                <div class="project-select-row">
                    <label class="project-select-label" for="project_select_input">Select project (optional):</label>
                </div>
                <div class="upload-actions">
                    <div class="upload-actions__pickers">
                        <button id="folder-btn" type="button" {% if not upload_enabled %}disabled{% endif %}>Choose Folder</button>
                        <button id="file-btn" type="button" {% if not upload_enabled %}disabled{% endif %}>Choose Files</button>
                        <input type="file" id="file-input" multiple class="file-input-hidden" {% if not upload_enabled %}disabled{% endif %}>
                        <input type="file" id="folder-input" multiple webkitdirectory directory class="file-input-hidden" {% if not upload_enabled %}disabled{% endif %}>
                    </div>
                    <div class="project-select-group">
                        <div class="project-select-controls">
                            <div id="project_select_wrapper" class="project-select-wrapper">
                                <input type="text"
                                       id="project_select_input"
                                       placeholder="Select project…"
                                       autocomplete="off"
                                       class="project-select-input">
                                <div id="project_select_display" class="project-select-display" aria-hidden="true"></div>
                                <span class="project-select-arrow" aria-hidden="true">▾</span>
                                <input type="hidden" id="project_select" value="">
                <div id="project_select_dropdown"
                                            style="display:none; position:absolute; left:0; right:0; top:100%;
                                            background:#fff; border:1px solid #007bff; border-top:none;
                                            z-index:1000; border-radius:0 0 6px 6px;">
                                </div>
                                {{ projects|json_script:"project-data" }}
                            </div>
                            <button type="button"
                                    id="project_refresh_btn"
                                    class="project-refresh-btn"
                                    title="Refresh projects"
                                    aria-label="Refresh projects">
                                ⟳
                            </button>
                        </div>
                    </div>
                    <div class="upload-actions__buttons">
                        <button id="upload-btn" type="button" {% if not upload_enabled %}disabled{% endif %}>Upload &amp; Import</button>
                        <button id="previous-step-btn" type="button" class="step-btn is-hidden">Previous step</button>
                        <button id="next-step-btn" type="button" class="step-btn is-hidden">Next step</button>
                        <button id="clear-all-btn" type="button" class="clear-all-btn">Clear all</button>
                    </div>
                </div>
                <div id="sem_edx_instructions" class="sem-edx-instructions">
                    <div class="sem-edx-instructions__row">
                        <span class="sem-edx-instructions__label">INSTRUCTIONS:</span>
                        <span class="sem-edx-instructions__text" id="sem_edx_instruction_primary"></span>
                    </div>
                    <div class="sem-edx-instructions__row sem-edx-instructions__row--secondary"
                         id="sem_edx_instruction_secondary_row">
                        <span class="sem-edx-instructions__label">INSTRUCTIONS:</span>
                        <span class="sem-edx-instructions__text" id="sem_edx_instruction_secondary"></span>
                    </div>
                </div>
                <div id="file-tree" class="file-tree" aria-live="polite"></div>
                <div id="sem_edx_settings" class="file-tree sem-edx-settings" aria-live="polite">
                    <div class="sem-edx-settings__options">
                        <label class="sem-edx-settings__option" for="sem_edx_setting_tables">
                            <input type="checkbox" id="sem_edx_setting_tables" checked>
                            <span>Create and append OMERO Table(s) with EDX spectra</span>
                        </label>
                        <label class="sem-edx-settings__option" for="sem_edx_setting_figures_attachment">
                            <input type="checkbox" id="sem_edx_setting_figures_attachment" checked>
                            <span>Create EDX spectra Figure(s) and append as attachment(s)</span>
                        </label>
                        <label class="sem-edx-settings__option" for="sem_edx_setting_figures_image">
                            <input type="checkbox" id="sem_edx_setting_figures_image" checked>
                            <span>Create EDX spectra Figure(s) and import as separate image(s)</span>
                        </label>
                    </div>
                    <div class="sem-edx-settings__actions">
                        <button type="button" id="sem_edx_settings_save">Save to database</button>
                    </div>
                </div>
                <div id="status" class="status"></div>
            </div>
        </div>

        <div id="project_dropdown_backdrop"
             style="display:none; position:fixed; inset:0; z-index:900;"></div>

        <div class="upload-action-row upload-actions" aria-live="polite">
            <div class="upload-action-slot">
                <button id="cancel-upload-btn" type="button" class="secondary-action action-hidden">Cancel upload</button>
            </div>
            <div class="upload-action-slot">
                <button id="cancel-import-btn" type="button" class="secondary-action action-hidden">Cancel import</button>
            </div>
        </div>

        <div id="progress-section">
            <h3>Progress</h3>
            <p id="progress-stage">Stage: Waiting to start…</p>
            <p id="progress-text">Waiting to start…</p>
            <div id="progress-bar-container">
                <div id="progress-bar">0%</div>
            </div>
            <pre id="progress-log"></pre>
        </div>
        <div id="duplicate-overlay" class="duplicate-overlay" aria-hidden="true"></div>
        <div id="duplicate-popup" class="duplicate-popup" role="alertdialog" aria-modal="true" aria-hidden="true">
            <p id="duplicate-message" class="duplicate-popup__message"></p>
            <button type="button" id="duplicate-ok-btn" class="duplicate-popup__btn">Ok</button>
        </div>
        <div id="compatibility-overlay" class="duplicate-overlay" aria-hidden="true"></div>
        <div id="compatibility-popup" class="duplicate-popup" role="alertdialog" aria-modal="true" aria-hidden="true">
            <p id="compatibility-message" class="duplicate-popup__message"></p>
            <div class="compatibility-popup__actions">
                <button type="button" id="compatibility-no-btn" class="duplicate-popup__btn">No</button>
                <button type="button" id="compatibility-yes-btn" class="duplicate-popup__btn">Yes</button>
            </div>
        </div>
        <div id="sem_edx_confirm-overlay" class="duplicate-overlay" aria-hidden="true"></div>
        <div id="sem_edx_confirm-popup" class="duplicate-popup" role="alertdialog" aria-modal="true" aria-hidden="true">
            <p id="sem_edx_confirm-message" class="duplicate-popup__message"></p>
            <div class="compatibility-popup__actions">
                <button type="button" id="sem_edx_confirm-no-btn" class="duplicate-popup__btn">No</button>
                <button type="button" id="sem_edx_confirm-yes-btn" class="duplicate-popup__btn">Yes</button>
            </div>
        </div>
        <div id="nb-modal-overlay"
             style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.3);
                    z-index:11000; align-items:center; justify-content:center;">
            <div style="background:#ffffff; padding:20px 24px; border-radius:8px;
                        box-shadow:0 10px 30px rgba(0,0,0,0.25);
                        font-size:13px; min-width:300px; max-width:500px;">
                <div id="nb-modal-message"
                     style="margin-bottom:16px;">
                </div>
                <div style="text-align:right;">
                    <button id="nb-modal-ok"
                            onclick="hideNonBlockingModal()"
                            style="padding:6px 14px; font-size:12px;">
                        OK
                    </button>
                </div>
            </div>
        </div>
        <div id="user-settings-overlay" class="user-settings-overlay" aria-hidden="true">
            <div class="user-settings-panel" role="dialog" aria-modal="true" aria-labelledby="user-settings-title">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                    <strong id="user-settings-title">User settings</strong>
                    <button type="button" id="user_settings_close" class="ai-option-btn ai-option-btn--modal">Close</button>
                </div>
                <div class="user-settings-grid">
                    <div class="user-setting-row">
                        <div class="user-setting-input">
                            <label for="user_setting_batch_size">Job batch size</label>
                            <input type="text"
                                   id="user_setting_batch_size"
                                   inputmode="numeric"
                                   style="width:50px; padding:8px; border-radius:6px; border:1px solid #007bff;">
                        </div>
                        <div class="user-setting-description">
                            <span class="user-setting-limit">[1-10]</span>
                            <span>Set higher for faster uploads and imports, lower for more granular progress updates.</span>
                        </div>
                    </div>
                    <div class="user-setting-row">
                        <div class="user-setting-input">
                            <label>Show all projects?</label>
                            <div class="user-setting-toggle" role="group" aria-label="Show all projects">
                                <input type="radio" id="user_setting_show_all_no" name="user_setting_show_all_projects" value="no">
                                <label for="user_setting_show_all_no">No</label>
                                <input type="radio" id="user_setting_show_all_yes" name="user_setting_show_all_projects" value="yes">
                                <label for="user_setting_show_all_yes">Yes</label>
                            </div>
                        </div>
                        <div class="user-setting-description">
                            <span>Toggle "Yes" to show all projects in the expanded project selection dropdown menu.</span>
                        </div>
                    </div>
                    <div class="user-setting-row">
                        <div class="user-setting-input">
                            <label>Remove "Clear all" button?</label>
                            <div class="user-setting-toggle" role="group" aria-label="Remove Clear all button">
                                <input type="radio" id="user_setting_remove_clear_all_no" name="user_setting_remove_clear_all" value="no">
                                <label for="user_setting_remove_clear_all_no">No</label>
                                <input type="radio" id="user_setting_remove_clear_all_yes" name="user_setting_remove_clear_all" value="yes">
                                <label for="user_setting_remove_clear_all_yes">Yes</label>
                            </div>
                        </div>
                        <div class="user-setting-description">
                            <span>Toggle "Yes" to remove the button from the interface in case of accidental clicks.</span>
                        </div>
                    </div>
                </div>
                <div class="user-settings-status" id="user_settings_status"></div>
                <div class="user-settings-actions">
                    <button type="button" id="user_settings_save">Save settings</button>
                    <button type="button" id="user_settings_restore">Restore defaults</button>
                </div>
            </div>
        </div>
    </div>

    <script defer>
const rootStatusUrl = new URL('{% url "omeroweb_upload_root_status" %}', window.location.href);
        const applyRootUserState = (isRootUser) => {
            if (!isRootUser) {
                return;
            }
            document.documentElement.classList.add('root-user-blocked');
            if (document.body) {
                document.body.classList.add('root-user-blocked');
            }
        };
        fetch(rootStatusUrl, { credentials: 'same-origin' })
            .then((resp) => (resp.ok ? resp.json() : null))
            .then((data) => {
                if (data && data.is_root_user === true) {
                    applyRootUserState(true);
                }
            })
            .catch(() => {
                // Ignore root user lookup failures.
            });
        let messages = {};
        try {
            messages = {{ messages_json|default:"{}"|safe }};
        } catch (e) {
            messages = {};
        }
        const formatMessage = (template, values = {}) => {
            const source = String(template || '');
            return source.replace(/\{(\w+)\}/g, (match, key) => (
                Object.prototype.hasOwnProperty.call(values, key) ? values[key] : match
            ));
        };
        const uploadCard = document.getElementById('upload-card');
        const uploadOverlay = uploadCard.querySelector('.upload-card__overlay');
        const startUrl = uploadCard.dataset.startUrl;
        const fileInput = document.getElementById('file-input');
        const fileBtn = document.getElementById('file-btn');
        const folderBtn = document.getElementById('folder-btn');
        const folderInput = document.getElementById('folder-input');
        const canUseDirectoryPicker = window.isSecureContext && typeof window.showDirectoryPicker === 'function';
        const canUseFolderInput = !!folderInput && ('webkitdirectory' in folderInput || 'directory' in folderInput);
        const uploadBtn = document.getElementById('upload-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const previousStepBtn = document.getElementById('previous-step-btn');
        const uploadIntroText = document.getElementById('upload_intro_text');
        const clearAllBtn = document.getElementById('clear-all-btn');
        const cancelUploadBtn = document.getElementById('cancel-upload-btn');
        const cancelImportBtn = document.getElementById('cancel-import-btn');
        const uploadActionsButtons = document.querySelector('.upload-actions__buttons');
        const statusEl = document.getElementById('status');
        const fileTree = document.getElementById('file-tree');
        const uploadEnabled = !uploadBtn.disabled;
        const projectSelect = document.getElementById('project_select');
        const projectSelectInput = document.getElementById('project_select_input');
        const projectSelectDropdown = document.getElementById('project_select_dropdown');
        const projectSelectWrapper = document.getElementById('project_select_wrapper');
        const projectSelectArrow = projectSelectWrapper?.querySelector('.project-select-arrow') || null;
        const projectSelectDisplay = document.getElementById('project_select_display');
        const projectSelectRow = document.querySelector('.project-select-row');
        const projectSelectGroup = document.querySelector('.project-select-group');
        const specialUploadSelect = document.getElementById('special_upload');
        const specialUploadInput = document.getElementById('special_upload_input');
        const specialUploadDropdown = document.getElementById('special_upload_dropdown');
        const specialUploadWrapper = document.getElementById('special_upload_wrapper');
        const specialUploadArrow = specialUploadWrapper?.querySelector('.project-select-arrow') || null;
        const specialUploadDisplay = document.getElementById('special_upload_display');
        const specialMethodsEnabled = {{ special_methods_enabled|yesno:"true,false" }};
        if (!specialMethodsEnabled && specialUploadWrapper) {
            specialUploadWrapper.style.display = 'none';
            if (specialUploadInput) {
                specialUploadInput.disabled = true;
            }
            if (specialUploadSelect) {
                specialUploadSelect.value = '';
            }
        }
        const projectDropdownBackdrop = document.getElementById('project_dropdown_backdrop');
        const projectDataScript = document.getElementById('project-data');
        const projectListUrl = new URL('{{ project_list_url }}', window.location.href);
        const collaborationToggle = document.getElementById('collaboration_toggle');
        const projectRefreshBtn = document.getElementById('project_refresh_btn');
        const collaborationSection = document.querySelector('.upload-utilities__collaboration');
        const compatibilitySection = document.querySelector('.upload-utilities__compatibility');
        const semEdxInstructions = document.getElementById('sem_edx_instructions');
        const semEdxInstructionPrimary = document.getElementById('sem_edx_instruction_primary');
        const semEdxInstructionSecondary = document.getElementById('sem_edx_instruction_secondary');
        const semEdxInstructionSecondaryRow = document.getElementById('sem_edx_instruction_secondary_row');
        const semEdxSettingsPanel = document.getElementById('sem_edx_settings');
        const semEdxSettingTables = document.getElementById('sem_edx_setting_tables');
        const semEdxSettingFiguresAttachment = document.getElementById('sem_edx_setting_figures_attachment');
        const semEdxSettingFiguresImage = document.getElementById('sem_edx_setting_figures_image');
        const semEdxSettingsSave = document.getElementById('sem_edx_settings_save');
        let isProjectRefreshInFlight = false;
        let projectData = projectDataScript ? JSON.parse(projectDataScript.textContent) : [];
        const MAX_USER_PROJECT_RESULTS = 15;
        const MAX_PROJECT_RESULTS = 15;
        const MAX_PROJECT_RESULTS_WITH_COLLAB = 20;
        let projectFilterTimeout = null;
        let activeProjectIndex = -1;
        let showAllProjectsEnabled = false;

        const progressSection = document.getElementById('progress-section');
        const progressBar = document.getElementById('progress-bar');
        const progressStage = document.getElementById('progress-stage');
        const progressText = document.getElementById('progress-text');
        const progressLog = document.getElementById('progress-log');
        const duplicateOverlay = document.getElementById('duplicate-overlay');
        const duplicatePopup = document.getElementById('duplicate-popup');
        const duplicateMessage = document.getElementById('duplicate-message');
        const duplicateOkBtn = document.getElementById('duplicate-ok-btn');
        const compatibilityOverlay = document.getElementById('compatibility-overlay');
        const compatibilityPopup = document.getElementById('compatibility-popup');
        const compatibilityMessage = document.getElementById('compatibility-message');
        const compatibilityYesBtn = document.getElementById('compatibility-yes-btn');
        const compatibilityNoBtn = document.getElementById('compatibility-no-btn');
        const semEdxConfirmOverlay = document.getElementById('sem_edx_confirm-overlay');
        const semEdxConfirmPopup = document.getElementById('sem_edx_confirm-popup');
        const semEdxConfirmMessage = document.getElementById('sem_edx_confirm-message');
        const semEdxConfirmYesBtn = document.getElementById('sem_edx_confirm-yes-btn');
        const semEdxConfirmNoBtn = document.getElementById('sem_edx_confirm-no-btn');
        const settingsMenuBtn = document.getElementById('settings_menu_btn');
        const settingsMenu = document.getElementById('settings_menu');
        const userSettingsBtn = document.getElementById('user_settings_btn');
        const userSettingsOverlay = document.getElementById('user-settings-overlay');
        const userSettingsClose = document.getElementById('user_settings_close');
        const userSettingsSave = document.getElementById('user_settings_save');
        const userSettingsRestore = document.getElementById('user_settings_restore');
        const userSettingsBatchInput = document.getElementById('user_setting_batch_size');
        const userSettingShowAllNo = document.getElementById('user_setting_show_all_no');
        const userSettingShowAllYes = document.getElementById('user_setting_show_all_yes');
        const userSettingRemoveClearAllNo = document.getElementById('user_setting_remove_clear_all_no');
        const userSettingRemoveClearAllYes = document.getElementById('user_setting_remove_clear_all_yes');
        const userSettingsStatus = document.getElementById('user_settings_status');
        const compatibilityToggle = document.getElementById('compatibility_toggle');

//        let specialUploadFixedWidth = null;
//        const syncSpecialUploadWidth = () => {
//            if (!specialUploadWrapper || !uploadActionsButtons || specialUploadFixedWidth !== null) return;
//            const buttonsWidth = uploadActionsButtons.offsetWidth;
//            if (buttonsWidth > 0) {
//                specialUploadFixedWidth = buttonsWidth;
//               specialUploadWrapper.style.width = `${buttonsWidth}px`;
//                specialUploadWrapper.style.minWidth = `${buttonsWidth}px`;
//                specialUploadWrapper.style.maxWidth = `${buttonsWidth}px`;
//            }
//        };
//
//        const lockSpecialUploadWidth = () => {
//            syncSpecialUploadWidth();
//            if (specialUploadFixedWidth !== null) {
//                window.removeEventListener('resize', lockSpecialUploadWidth);
//                window.removeEventListener('load', lockSpecialUploadWidth);
//            }
//        };
//
//        lockSpecialUploadWidth();
//        window.addEventListener('resize', lockSpecialUploadWidth);
//        window.addEventListener('load', lockSpecialUploadWidth);

        let pendingFiles = [];
        const expandedNodes = new Set();
        const importJobs = new Map();
        const importLogEntries = [];
        const importLogState = new Map();
        let importPollTimer = null;
        let isUploading = false;
        let cancelUploadRequested = false;
        let compatibilityPopupResolver = null;
        let semEdxConfirmPopupResolver = null;
        let suppressProjectDropdownOpenOnFocusOnce = false;
        let suppressSpecialUploadDropdownOpenOnFocusOnce = false;
        let uploadTotalBytes = 0;
        const uploadProgressEntries = new Map();
        const activeUploadRequests = new Set();
        const currentUserId = {{ user_id|default:"null"|safe }};
        const storage =
            (() => {
                try {
                    const testKey = '__omero_upload_storage_test__';
                    window.localStorage.setItem(testKey, '1');
                    window.localStorage.removeItem(testKey);
                    return window.localStorage;
                } catch (error) {
                    return null;
                }
            })();
        const storageKeySuffix = currentUserId ? `_u${currentUserId}` : '';
        const makeStorageKey = (baseKey) => `${baseKey}${storageKeySuffix}`;
        const importJobsStorageKey = makeStorageKey('omeroweb_upload_import_jobs_v1');
        const importLogsStorageKey = makeStorageKey('omeroweb_upload_import_logs_v1');
        const userSettingsStorageKey = makeStorageKey('omeroweb_upload_user_settings_v1');
        const projectSelectionStorageKey = makeStorageKey('omeroweb_upload_project_selection_v1');
        const specialUploadSelectionStorageKey = makeStorageKey('omeroweb_upload_special_upload_selection_v1');
        const collaborationToggleStorageKey = makeStorageKey('omeroweb_upload_collaboration_toggle_v1');
        const userSettingsSaveUrl = new URL('user-settings/save/', window.location.href);
        const specialMethodSettingsSaveUrl = new URL('special-method-settings/save/', window.location.href);
        const specialMethodSettingsLoadUrl = new URL('special-method-settings/load/', window.location.href);
        const compatibilityToggleStorageKey = makeStorageKey('omeroweb_upload_compatibility_toggle_v1');
        const compatibilityPausedStorageKey = makeStorageKey('omeroweb_upload_compatibility_toggle_paused_v1');
        const semEdxAssociationsStorageKey = makeStorageKey('omeroweb_upload_sem_edx_associations_v1');
        const specialUploadOptions = specialMethodsEnabled
            ? [
                { value: '', label: 'No special method (clear selection)', isEmpty: true },
                { value: 'sem_edx_spectra', label: 'Zeiss GeminiSEM 450: EDX spectra' },
            ]
            : [{ value: '', label: 'No special method (clear selection)', isEmpty: true }];
        let activeSpecialUploadIndex = -1;
        let semEdxModeActive = false;
        let semEdxInstructionStep = 1;
        const semEdxStep1Lines = [
            '1) Add all SEM EDX image files and associated txt spectra. Data can also be arranged in separate folders.',
            'Preferred, per folder, is one image and one or more txt spectra, which will be automatically appended to the image.',
        ];
        const semEdxStep2Lines = [
            '2) Confirm or manually edit the associations between SEM images and spectra files.',
            'Multiple txt files can be appended to a single image.',
        ];
        const semEdxStep3Lines = [
            '3) Adjust the import settings of the SEM EDX spectra, or directly proceed with the next step (Upload & Import).',
            'The special method settings can be saved in the user database for automatic retrieval in subsequent imports.',
        ];
        const semEdxSettingsDefaults = {
            create_tables: true,
            create_figures_attachments: true,
            create_figures_images: true,
        };
        let semEdxSettingsDraft = null;
        const specialMethodSettingsCache = new Map();
        const specialMethodSettingsLoading = new Map();
        let semEdxAssociationMode = 'automatic';
        const semEdxManualAssociations = new Map();
        let semEdxManualInitialized = false;
        const semEdxExpandedNodes = new Set();
        let semEdxExpandedNodesInitialized = false;
        let semEdxAssociationCache = new Map();
        const semEdxTxtCache = new Map();
        let semEdxAssociationVersion = 0;
        let semEdxAssociationLoading = false;
        let semEdxAssociationReady = false;
        let skipSpecialUploadReset = false;
        loadSemEdxAssociationsFromStorage();

        function setStatus(message, type) {
            statusEl.textContent = message || '';
            statusEl.classList.remove('error', 'success');
            if (type) {
                statusEl.classList.add(type);
            }
        }

        function normalizeSemEdxAssociations(raw) {
            const map = new Map();
            if (!raw || typeof raw !== 'object') return map;
            Object.entries(raw).forEach(([key, value]) => {
                if (!Array.isArray(value)) return;
                const filtered = value
                    .map((item) => String(item))
                    .filter((item) => item);
                if (filtered.length) {
                    map.set(key, Array.from(new Set(filtered)));
                }
            });
            return map;
        }

        function serializeSemEdxAssociations(map) {
            const data = {};
            map.forEach((value, key) => {
                if (Array.isArray(value) && value.length) {
                    data[key] = [...value];
                }
            });
            return data;
        }

        function loadSemEdxAssociationsFromStorage() {
            try {
                const raw = window.sessionStorage?.getItem(semEdxAssociationsStorageKey);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                const manual = normalizeSemEdxAssociations(parsed?.manual);
                const automatic = normalizeSemEdxAssociations(parsed?.automatic);
                manual.forEach((value, key) => {
                    semEdxManualAssociations.set(key, value);
                });
                semEdxManualInitialized = semEdxManualAssociations.size > 0;
                if (automatic.size) {
                    semEdxAssociationCache = new Map(automatic);
                }
            } catch (error) {
                // Ignore storage errors.
            }
        }

        function saveSemEdxAssociationsToStorage() {
            try {
                const payload = {
                    manual: serializeSemEdxAssociations(semEdxManualAssociations),
                    automatic: serializeSemEdxAssociations(semEdxAssociationCache),
                };
                window.sessionStorage?.setItem(semEdxAssociationsStorageKey, JSON.stringify(payload));
            } catch (error) {
                // Ignore storage errors.
            }
        }

        function normalizeSpecialMethodSettings(raw, defaults) {
            const base = { ...(defaults || {}) };
            if (!raw || typeof raw !== 'object') {
                return base;
            }
            Object.keys(base).forEach((key) => {
                if (Object.prototype.hasOwnProperty.call(raw, key)) {
                    base[key] = !!raw[key];
                }
            });
            return base;
        }

        function applySemEdxSettings(settings) {
            const normalized = normalizeSpecialMethodSettings(settings, semEdxSettingsDefaults);
            if (semEdxSettingTables) {
                semEdxSettingTables.checked = !!normalized.create_tables;
            }
            if (semEdxSettingFiguresAttachment) {
                semEdxSettingFiguresAttachment.checked = !!normalized.create_figures_attachments;
            }
            if (semEdxSettingFiguresImage) {
                semEdxSettingFiguresImage.checked = !!normalized.create_figures_images;
            }
            semEdxSettingsDraft = normalized;
        }

        function getSemEdxSettingsPayload() {
            return normalizeSpecialMethodSettings({
                create_tables: semEdxSettingTables?.checked ?? true,
                create_figures_attachments: semEdxSettingFiguresAttachment?.checked ?? true,
                create_figures_images: semEdxSettingFiguresImage?.checked ?? true,
            }, semEdxSettingsDefaults);
        }

        function resetSemEdxSettingsDraft() {
            semEdxSettingsDraft = null;
        }

        function syncSemEdxSettingsDraft() {
            semEdxSettingsDraft = getSemEdxSettingsPayload();
        }

        async function loadSpecialMethodSettingsFromDatabase(methodKey, defaults) {
            try {
                const response = await fetch(specialMethodSettingsLoadUrl, {
                    method: 'POST',
                    headers: setRequestHeaders({ 'Content-Type': 'application/json' }),
                    credentials: 'same-origin',
                    body: JSON.stringify({ method: methodKey }),
                });
                const data = await parseJsonResponse(response);
                if (!response.ok || data?.error) {
                    throw new Error(data?.error || `Failed to load settings (status ${response.status}).`);
                }
                return normalizeSpecialMethodSettings(data?.settings, defaults);
            } catch (error) {
                showNonBlockingModal(formatMessage(messages.specialMethodSettingsLoadError, { error }));
                return normalizeSpecialMethodSettings(null, defaults);
            }
        }

        async function ensureSpecialMethodSettingsLoaded(methodKey, defaults, applySettings) {
            if (specialMethodSettingsCache.has(methodKey)) {
                const cached = specialMethodSettingsCache.get(methodKey);
                if (applySettings) {
                    applySettings(cached);
                }
                return cached;
            }

            if (specialMethodSettingsLoading.has(methodKey)) {
                const pending = await specialMethodSettingsLoading.get(methodKey);
                if (applySettings) {
                    applySettings(pending);
                }
                return pending;
            }

            const loadPromise = loadSpecialMethodSettingsFromDatabase(methodKey, defaults);
            specialMethodSettingsLoading.set(methodKey, loadPromise);
            const loaded = await loadPromise;
            specialMethodSettingsLoading.delete(methodKey);
            specialMethodSettingsCache.set(methodKey, loaded);
            if (applySettings) {
                applySettings(loaded);
            }
            return loaded;
        }

        function saveSpecialMethodSettingsToDatabase(methodKey, settings, options = {}) {
            const { onSuccess, onError } = options;
            return fetch(specialMethodSettingsSaveUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ method: methodKey, settings }),
            })
                .then((resp) => resp.json())
                .then((data) => {
                    if (data?.error) {
                        showNonBlockingModal(data.error);
                        if (typeof onError === 'function') {
                            onError(data.error);
                        }
                        return false;
                    }

                    const saveSucceeded = data && data.success === true;

                    if (saveSucceeded) {
                        showNonBlockingModal(messages.specialMethodSettingsSavedDb);
                        specialMethodSettingsCache.set(methodKey, normalizeSpecialMethodSettings(data.settings, settings));
                    }

                    if (typeof onSuccess === 'function') {
                        onSuccess(data);
                    }
                    return saveSucceeded;
                })
                .catch((err) => {
                    showNonBlockingModal(formatMessage(messages.specialMethodSettingsSaveError, { error: err }));
                    if (typeof onError === 'function') {
                        onError(err);
                    }
                    return false;
                });
        }

        function hasActiveImport() {
            for (const job of importJobs.values()) {
                if (job.status !== 'done' && job.status !== 'error') {
                    return true;
                }
            }
            return false;
        }

        function isSemEdxAddLocked() {
            return isSemEdxSelected() && semEdxInstructionStep > 1;
        }

        function updateUploadControlAvailability() {
            const shouldDisable = isUploading || !uploadEnabled || isSemEdxAddLocked();
            fileInput.disabled = shouldDisable;
            folderInput.disabled = shouldDisable;
            if (fileBtn) {
                fileBtn.disabled = shouldDisable;
            }
            if (folderBtn) {
                folderBtn.disabled = shouldDisable;
            }
            uploadBtn.disabled = isUploading || !uploadEnabled;
        }

        function resetSemEdxStateAfterUpload() {
            if (!isSemEdxSelected()) return;
            semEdxManualAssociations.clear();
            semEdxManualInitialized = false;
            semEdxExpandedNodes.clear();
            semEdxExpandedNodesInitialized = false;
            semEdxAssociationCache = new Map();
            semEdxTxtCache.clear();
            semEdxAssociationVersion += 1;
            semEdxAssociationLoading = false;
            semEdxAssociationReady = false;
            setSemEdxAssociationMode('automatic');
            setSemEdxInstructionsStep(1);
            resetSemEdxSettingsDraft();
            saveSemEdxAssociationsToStorage();
            updateSemEdxStatus();
        }

        function resetSpecialUploadStateAfterUpload() {
            if (!specialUploadSelect?.value) {
                return;
            }
            if (isSemEdxSelected()) {
                resetSemEdxStateAfterUpload();
            }
        }

        function setUploadingState(active, statusText) {
            const wasUploading = isUploading;
            isUploading = active;
            uploadCard.classList.toggle('is-uploading', active);
            updateUploadControlAvailability();
            if (!active) {
                resetUploadProgress();
                if (wasUploading) {
                    if (!skipSpecialUploadReset) {
                        resetSpecialUploadStateAfterUpload();
                    }
                    skipSpecialUploadReset = false;
                }
            } else if (statusText && uploadOverlay) {
                uploadOverlay.textContent = statusText;
            }
            updateCancelButtons();
        }

        function registerActiveRequest(xhr) {
            activeUploadRequests.add(xhr);
            const cleanup = () => {
                activeUploadRequests.delete(xhr);
                if (uploadProgressEntries && uploadProgressEntries.has(xhr)) {
                    uploadProgressEntries.delete(xhr);
                }
            };
            xhr.addEventListener('loadend', cleanup, { once: true });
            xhr.addEventListener('abort', cleanup, { once: true });
            xhr.addEventListener('error', cleanup, { once: true });
            xhr.addEventListener('timeout', cleanup, { once: true });
        }

        function updateCompatibilityOverlayProgress() {
            if (!uploadOverlay || !isUploading) {
                return;
            }
            const job = Array.from(importJobs.values())[0];
            if (!job) return;
            if (job.compatibility_enabled === false) {
                uploadOverlay.textContent = 'PREPARING IMPORT...';
                return;
            }
            
            const total = job.compatibility_total || 0;
            if (total === 0) return;

            uploadOverlay.textContent = 'CHECKING COMPATIBILITY...';
        }

        function updateUploadButtonLabel() {
            if (window.pendingImportJob) {
                uploadBtn.textContent = 'Continue Import';
            } else {
                uploadBtn.textContent = hasActiveImport() ? 'Upload & append to Import' : 'Upload & Import';
            }
        }

        function normalizeByteSize(value) {
            const size = Number(value);
            if (!Number.isFinite(size) || size <= 0) {
                return 0;
            }
            return size;
        }

        function getPendingTotalBytes() {
            return pendingFiles.reduce((acc, entry) => acc + normalizeByteSize(entry.file?.size), 0);
        }

        function resetUploadProgress() {
            uploadTotalBytes = 0;
            uploadProgressEntries.clear();
            if (uploadOverlay) {
                uploadOverlay.textContent = 'UPLOADING';
            }
        }

        function updateUploadOverlayProgress() {
            if (!uploadOverlay || !isUploading) {
                if (uploadOverlay) {
                    uploadOverlay.textContent = 'UPLOADING';
                }
                return;
            }
            const totalBytes = Number.isFinite(uploadTotalBytes) && uploadTotalBytes > 0
                ? uploadTotalBytes
                : Array.from(uploadProgressEntries.values()).reduce(
                    (acc, entry) => acc + normalizeByteSize(entry.total),
                    0
                );
            if (!totalBytes) {
                uploadOverlay.textContent = 'UPLOADING';
                return;
            }
            const loaded = Array.from(uploadProgressEntries.values()).reduce((acc, entry) => {
                const loadedBytes = normalizeByteSize(entry.loaded);
                const entryTotal = normalizeByteSize(entry.total);
                return acc + (entryTotal ? Math.min(loadedBytes, entryTotal) : loadedBytes);
            }, 0);
            const percent = Math.min(100, Math.floor((loaded / totalBytes) * 100));
            uploadOverlay.textContent = `UPLOADING (${percent}%)`;
        }

        function setUploadProgressEntry(key, loaded, total) {
            uploadProgressEntries.set(key, {
                loaded: normalizeByteSize(loaded),
                total: normalizeByteSize(total),
            });
            updateUploadOverlayProgress();
        }

        function showSettingsMenu(show) {
            if (!settingsMenu) return;
            settingsMenu.style.display = show ? 'block' : 'none';
        }

        function normalizeProjectEntry(entry) {
            if (!entry) return null;
            if (Array.isArray(entry)) {
                const [projectId, projectName, owner] = entry;
                return {
                    id: projectId ? String(projectId) : '',
                    name: projectName || '',
                    owner: owner || '',
                };
            }
            if (typeof entry === 'object') {
                return {
                    id: entry.id ? String(entry.id) : '',
                    name: entry.name || '',
                    owner: entry.owner || '',
                };
            }
            return null;
        }

        function normalizeProjectData(raw) {
            if (Array.isArray(raw)) {
                return {
                    owned: raw.map(normalizeProjectEntry).filter((entry) => entry && entry.id),
                    collab: [],
                };
            }
            const owned = Array.isArray(raw?.owned) ? raw.owned : [];
            const collab = Array.isArray(raw?.collab) ? raw.collab : [];
            return {
                owned: owned.map(normalizeProjectEntry).filter((entry) => entry && entry.id),
                collab: collab.map(normalizeProjectEntry).filter((entry) => entry && entry.id),
            };
        }

        projectData = normalizeProjectData(projectData);
        updateCollaborationVisibility();

        function isCollaborationEnabled() {
            return !!collaborationToggle?.checked;
        }

        function updateCollaborationVisibility() {
            const hasCollaborationOptions = Array.isArray(projectData?.collab) && projectData.collab.length > 0;
            if (!collaborationSection) {
                return hasCollaborationOptions;
            }
            if (hasCollaborationOptions) {
                collaborationSection.style.display = '';
            } else {
                collaborationSection.style.display = 'none';
                if (storage) {
                    try {
                        storage.removeItem(collaborationToggleStorageKey);
                    } catch (error) {
                        // Ignore storage failures.
                    }
                }
                applyCollaborationState(false, { persist: false, refresh: false });
            }
            return hasCollaborationOptions;
        }

        function hasCollaborations() {
            return Array.isArray(projectData?.collab) && projectData.collab.length > 0;
        }

        function getProjectResultsLimit(includeCollab = false) {
            if (showAllProjectsEnabled) return Infinity;
            if (includeCollab && hasCollaborations()) {
                return MAX_PROJECT_RESULTS_WITH_COLLAB;
            }
            return MAX_PROJECT_RESULTS;
        }

        function getProjectLabel(projectId, projectName) {
            return String(projectName || projectId || '');
        }

        function getProjectEntryLabel(entry) {
            const baseLabel = getProjectLabel(entry?.id, entry?.name);
            if (entry?.owner) {
                return `${entry.owner} → ${baseLabel}`;
            }
            return baseLabel;
        }

        function isCollabEntry(entry) {
            return !!entry?.owner;
        }

        function getNumericSortValue(label) {
            return /^\s*\d+\s*$/.test(label) ? Number(label.trim()) : null;
        }

        function sortOwnedEntries(entries) {
            return entries.sort((entryA, entryB) => {
                const labelA = getProjectLabel(entryA?.id, entryA?.name);
                const labelB = getProjectLabel(entryB?.id, entryB?.name);
                const numericA = getNumericSortValue(labelA);
                const numericB = getNumericSortValue(labelB);
                if (numericA !== null && numericB !== null) {
                    return numericB - numericA;
                }
                if (numericA !== null) return -1;
                if (numericB !== null) return 1;
                const labelCompare = labelA.localeCompare(labelB, undefined, { numeric: true, sensitivity: 'base' });
                if (labelCompare !== 0) return labelCompare;
                return String(entryA?.id || '').localeCompare(
                    String(entryB?.id || ''),
                    undefined,
                    { numeric: true, sensitivity: 'base' }
                );
            });
        }

        function sortCollabEntries(entries) {
            const byOwner = new Map();
            entries.forEach((entry) => {
                const owner = entry.owner || 'Unknown user';
                if (!byOwner.has(owner)) {
                    byOwner.set(owner, []);
                }
                byOwner.get(owner).push(entry);
            });
            const owners = Array.from(byOwner.keys()).sort((a, b) => (
                a.localeCompare(b, undefined, { sensitivity: 'base' })
            ));
            const sorted = [];
            owners.forEach((owner) => {
                const items = byOwner.get(owner) || [];
                items.sort((entryA, entryB) => {
                    const labelA = getProjectLabel(entryA?.id, entryA?.name);
                    const labelB = getProjectLabel(entryB?.id, entryB?.name);
                    return labelA.localeCompare(labelB, undefined, { numeric: true, sensitivity: 'base' });
                });
                sorted.push(...items);
            });
            return sorted;
        }

        function getOrderedProjectEntries(includeCollab = false) {
            const owned = sortOwnedEntries([...(projectData?.owned || [])]);
            if (!includeCollab) {
                return owned;
            }
            const collab = sortCollabEntries([...(projectData?.collab || [])]);
            return [...owned, ...collab];
        }

        function findProjectEntryById(projectId, includeCollab = false) {
            if (!projectId) return null;
            const list = includeCollab
                ? [...(projectData?.owned || []), ...(projectData?.collab || [])]
                : [...(projectData?.owned || [])];
            return list.find((entry) => String(entry.id) === String(projectId)) || null;
        }

        function getProjectOptions() {
            return projectSelectDropdown
                ? Array.from(projectSelectDropdown.querySelectorAll('.project-option'))
                : [];
        }

        function saveProjectSelection(projectId, projectName) {
            if (!storage) return;
            const normalizedId = projectId ? String(projectId) : '';
            const normalizedName = projectName ? String(projectName) : '';
            try {
                if (!normalizedId && !normalizedName) {
                    storage.removeItem(projectSelectionStorageKey);
                    return;
                }
                storage.setItem(
                    projectSelectionStorageKey,
                    JSON.stringify({ projectId: normalizedId, projectName: normalizedName })
                );
            } catch (error) {
                // Ignore storage failures.
            }
        }

        function saveCollaborationState(enabled) {
            if (!storage) return;
            try {
                storage.setItem(collaborationToggleStorageKey, JSON.stringify({ enabled: !!enabled }));
            } catch (error) {
                // Ignore storage failures.
            }
        }

        function loadCollaborationState() {
            if (!storage) return null;
            try {
                const raw = storage.getItem(collaborationToggleStorageKey);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return typeof parsed?.enabled === 'boolean' ? parsed.enabled : null;
            } catch (error) {
                return null;
            }
        }

        function saveCompatibilityState(enabled) {
            if (!storage) return;
            try {
                storage.setItem(compatibilityToggleStorageKey, JSON.stringify({ enabled: !!enabled }));
            } catch (error) {
                // Ignore storage failures.
            }
        }

        function loadCompatibilityState() {
            if (!storage) return null;
            try {
                const raw = storage.getItem(compatibilityToggleStorageKey);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return typeof parsed?.enabled === 'boolean' ? parsed.enabled : null;
            } catch (error) {
                return null;
            }
        }

        function applyCompatibilityState(enabled) {
            if (compatibilityToggle) {
                compatibilityToggle.checked = !!enabled;
            }
            saveCompatibilityState(enabled);
        }

        function isCompatibilityEnabled() {
            return compatibilityToggle?.checked ?? false;
        }

        function saveCompatibilityPausedState(enabled) {
            if (!storage) return;
            try {
                storage.setItem(compatibilityPausedStorageKey, JSON.stringify({ enabled: !!enabled }));
            } catch (error) {
                // Ignore storage failures.
            }
        }

        function loadCompatibilityPausedState() {
            if (!storage) return null;
            try {
                const raw = storage.getItem(compatibilityPausedStorageKey);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return typeof parsed?.enabled === 'boolean' ? parsed.enabled : null;
            } catch (error) {
                return null;
            }
        }

        function applyCollaborationState(enabled, options = {}) {
            const { persist = true, refresh = false } = options;
            if (collaborationToggle) {
                collaborationToggle.checked = !!enabled;
            }
            if (persist) {
                saveCollaborationState(enabled);
            }
            
            const isDropdownOpen = projectSelectDropdown?.style.display === 'block';
            
            // ALWAYS clear selection and search when collaboration toggle changes
            clearProjectSelection({ persist: true });
            
            if (isDropdownOpen) {
                // Dropdown is open - clear search and reset active index
                projectSelectInput.value = '';
                setActiveProjectIndex(-1);
                renderProjectOptions('');
            }
            
            if (refresh) {
                refreshProjectList();
            }
        }

        function updateProjectSelectionDisplay() {
            if (!projectSelectDisplay || !projectSelectWrapper || !projectSelectInput) return;
            const selectedName = projectSelectInput.dataset.selectedName || '';
            const selectedOwner = projectSelectInput.dataset.selectedOwner || '';
            const selectedBaseName = projectSelectInput.dataset.selectedBaseName || selectedName;
            const isCollab = projectSelectInput.dataset.selectedIsCollab === 'true';
            if (!selectedName) {
                projectSelectDisplay.innerHTML = '';
                projectSelectDisplay.style.display = 'none';
                projectSelectDisplay.classList.remove('is-collab');
                projectSelectWrapper.classList.remove('is-display-active');
                return;
            }
            projectSelectDisplay.innerHTML = '';
            projectSelectDisplay.style.display = 'flex';
            projectSelectWrapper.classList.add('is-display-active');
            projectSelectDisplay.classList.toggle('is-collab', isCollab);
            if (isCollab && selectedOwner) {
                const ownerSpan = document.createElement('span');
                ownerSpan.className = 'project-select-owner';
                ownerSpan.textContent = selectedOwner;
                const arrowSpan = document.createElement('span');
                arrowSpan.textContent = '→';
                const nameSpan = document.createElement('span');
                nameSpan.textContent = selectedBaseName;
                projectSelectDisplay.append(ownerSpan, arrowSpan, nameSpan);
            } else {
                projectSelectDisplay.textContent = selectedName;
            }
        }

        function setProjectSelection(projectId, projectName, options = {}) {
            const { persist = true, isCollab = false, owner = '', baseName = '' } = options;
            const normalizedId = projectId ? String(projectId) : '';
            const normalizedName = projectName ? String(projectName) : '';
            if (projectSelect) {
                projectSelect.value = normalizedId;
            }
            if (projectSelectInput) {
                projectSelectInput.value = normalizedName;
                projectSelectInput.dataset.selectedName = normalizedName;
                projectSelectInput.dataset.selectedIsCollab = isCollab ? 'true' : 'false';
                projectSelectInput.dataset.selectedOwner = owner || '';
                projectSelectInput.dataset.selectedBaseName = baseName || normalizedName;
                projectSelectInput.classList.toggle('is-collab', isCollab);
            }
            updateProjectSelectionDisplay();
            if (persist) {
                saveProjectSelection(normalizedId, normalizedName);
            }
        }

        function clearProjectSelection(options = {}) {
            const { persist = true } = options;
            if (projectSelect) {
                projectSelect.value = '';
            }
            if (projectSelectInput) {
                projectSelectInput.value = '';
                projectSelectInput.dataset.selectedName = '';
                projectSelectInput.dataset.selectedIsCollab = 'false';
                projectSelectInput.dataset.selectedOwner = '';
                projectSelectInput.dataset.selectedBaseName = '';
                projectSelectInput.classList.remove('is-collab');
            }
            updateProjectSelectionDisplay();
            if (persist && storage) {
                try {
                    storage.removeItem(projectSelectionStorageKey);
                } catch (error) {
                    // Ignore storage failures.
                }
            }
        }

        function restoreProjectSelection() {
            if (!storage) return;
            try {
                const raw = storage.getItem(projectSelectionStorageKey);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                const storedId = parsed?.projectId ? String(parsed.projectId) : '';
                if (!storedId) {
                    clearProjectSelection({ persist: false });
                    return;
                }
                const match = findProjectEntryById(storedId, isCollaborationEnabled());
                if (!match) {
                    clearProjectSelection({ persist: false });
                    return;
                }
                const label = parsed?.projectName || getProjectEntryLabel(match);
                setProjectSelection(match.id, label, {
                    persist: false,
                    isCollab: isCollabEntry(match),
                    owner: match?.owner || '',
                    baseName: getProjectLabel(match?.id, match?.name),
                });
            } catch (error) {
                clearProjectSelection({ persist: false });
            }
        }

        function setActiveProjectIndex(index, useKeyboard = false) {
            const options = getProjectOptions();
            if (options.length === 0) {
                activeProjectIndex = -1;
                return;
            }
            if (projectSelectDropdown) {
                if (useKeyboard) {
                    projectSelectDropdown.classList.add('keyboard-active');
                } else {
                    projectSelectDropdown.classList.remove('keyboard-active');
                }
            }
            if (index < 0) {
                options.forEach((option) => option.classList.remove('is-active'));
                activeProjectIndex = -1;
                return;
            }
            const clamped = Math.max(0, Math.min(index, options.length - 1));
            options.forEach((option, idx) => {
                if (idx === clamped) {
                    option.classList.add('is-active');
                    option.scrollIntoView({ block: 'nearest' });
                } else {
                    option.classList.remove('is-active');
                }
            });
            activeProjectIndex = clamped;
        }

        function selectProjectOption(option) {
            if (!option) return;
            const projectId = option.dataset.projectId || '';
            const projectName = option.dataset.projectName || option.textContent || '';
            const isCollab = option.dataset.isCollab === 'true';
            const owner = option.dataset.projectOwner || '';
            const baseName = option.dataset.projectBaseName || '';
            if (!projectId && option.classList.contains('is-empty')) {
                clearProjectSelection();
            } else {
                setProjectSelection(projectId, projectName, { isCollab, owner, baseName });
            }
            closeProjectDropdown(false);
        }

        function renderProjectOptions(query) {
            if (!projectSelectDropdown) return;
            const normalizedQuery = query.trim().toLowerCase();
            const matches = [];
            const orderedEntries = getOrderedProjectEntries(isCollaborationEnabled());
            const totalProjects = orderedEntries.length;
            let totalMatches = 0;
            let ownedMatches = 0;
            const maxResults = getProjectResultsLimit(isCollaborationEnabled());
            const allowAll = !Number.isFinite(maxResults);

            for (let i = 0; i < orderedEntries.length; i += 1) {
                const entry = orderedEntries[i];
                const label = getProjectEntryLabel(entry);
                const id = entry?.id || '';
                const owner = entry?.owner || '';
                const isMatch = !normalizedQuery
                    || String(label).toLowerCase().includes(normalizedQuery)
                    || String(id).toLowerCase().includes(normalizedQuery)
                    || String(owner).toLowerCase().includes(normalizedQuery);
                if (isMatch) {
                    totalMatches += 1;
                    if (allowAll) {
                        matches.push(entry);
                    } else if (isCollabEntry(entry)) {
                        if (matches.length < maxResults) {
                            matches.push(entry);
                        }
                    } else if (ownedMatches < MAX_USER_PROJECT_RESULTS && matches.length < maxResults) {
                        ownedMatches += 1;
                        matches.push(entry);
                    }
                }
            }

            projectSelectDropdown.innerHTML = '';
            const listContainer = document.createElement('div');
            listContainer.className = 'project-select-dropdown__list';
            projectSelectDropdown.appendChild(listContainer);

            if (!normalizedQuery) {
                const emptyOption = document.createElement('div');
                emptyOption.className = 'project-option is-empty';
                emptyOption.dataset.projectId = '';
                emptyOption.dataset.projectName = '';
                emptyOption.style.padding = '8px 12px';
                emptyOption.style.cursor = 'pointer';
                emptyOption.style.whiteSpace = 'nowrap';
                emptyOption.textContent = 'No project (clear selection)';
                listContainer.appendChild(emptyOption);
            }

            if (matches.length > 0) {
                matches.forEach((entry) => {
                    const option = document.createElement('div');
                    option.className = 'project-option';
                    option.dataset.projectId = entry.id;
                    option.dataset.projectName = getProjectEntryLabel(entry);
                    option.dataset.projectBaseName = getProjectLabel(entry?.id, entry?.name);
                    option.dataset.isCollab = isCollabEntry(entry) ? 'true' : 'false';
                    option.style.padding = '8px 12px';
                    option.style.cursor = 'pointer';
                    option.style.whiteSpace = 'nowrap';
                    if (isCollabEntry(entry)) {
                        option.classList.add('is-collab');
                        option.dataset.projectOwner = entry.owner || '';
                        const ownerSpan = document.createElement('span');
                        ownerSpan.className = 'project-option-owner';
                        ownerSpan.textContent = entry.owner || '';
                        const arrowSpan = document.createElement('span');
                        arrowSpan.className = 'project-option-arrow';
                        arrowSpan.textContent = '→';
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = getProjectLabel(entry?.id, entry?.name);
                        option.append(ownerSpan, arrowSpan, nameSpan);
                    } else {
                        option.textContent = getProjectEntryLabel(entry);
                    }
                    listContainer.appendChild(option);
                });
            }

            const statusRow = document.createElement('div');
            statusRow.className = 'project-select-dropdown__status';
            if (Number.isFinite(maxResults) && totalMatches > maxResults) {
                statusRow.textContent = `Showing ${maxResults} of ${totalMatches} projects. Search to narrow down.`;
            } else if (totalMatches > 0) {
                statusRow.textContent = `${totalMatches} project${totalMatches === 1 ? '' : 's'} found`;
            } else {
                statusRow.textContent = 'No projects found';
            }
            projectSelectDropdown.appendChild(statusRow);
            setActiveProjectIndex(-1);
        }

        function syncProjectSelectionWithMode() {
            if (!projectSelect) return;
            const selectedId = projectSelect.value;
            if (!selectedId) return;
            const match = findProjectEntryById(selectedId, isCollaborationEnabled());
            if (!match) {
                clearProjectSelection();
                return;
            }
            const label = getProjectEntryLabel(match);
            setProjectSelection(match.id, label, {
                persist: false,
                isCollab: isCollabEntry(match),
                owner: match?.owner || '',
                baseName: getProjectLabel(match?.id, match?.name),
            });
        }

        function updateProjectData(data) {
            projectData = normalizeProjectData(data);
            updateCollaborationVisibility();
            syncProjectSelectionWithMode();
            if (projectSelectDropdown?.style.display === 'block') {
                renderProjectOptions(projectSelectInput?.value || '');
            }
        }

        async function refreshProjectList() {
            if (!projectListUrl) return;
            if (isProjectRefreshInFlight) return;
            isProjectRefreshInFlight = true;
            if (projectRefreshBtn) {
                projectRefreshBtn.classList.add('is-loading');
                projectRefreshBtn.setAttribute('aria-busy', 'true');
            }
            try {
                const response = await fetch(projectListUrl.toString(), {
                    method: 'GET',
                    cache: 'no-store',
                    credentials: 'same-origin',
                    headers: setRequestHeaders({}, null),
                });
                if (!response.ok) {
                    throw new Error(`Request failed: ${response.status}`);
                }
                const data = await response.json();
                updateProjectData(data);
            } catch (error) {
                setStatus('Unable to refresh project list.', 'error');
            } finally {
                isProjectRefreshInFlight = false;
                if (projectRefreshBtn) {
                    projectRefreshBtn.classList.remove('is-loading');
                    projectRefreshBtn.setAttribute('aria-busy', 'false');
                }
            }
        }

        function openProjectDropdown() {
            if (!projectSelectDropdown || !projectSelectInput) return;
            closeSpecialUploadDropdown(false);
            projectSelectDropdown.style.display = 'block';
            projectSelectDropdown.classList.remove('keyboard-active');
            projectSelectWrapper?.classList.add('is-open');
            if (projectSelectArrow) {
                projectSelectArrow.textContent = '▴';
            }
            projectSelectWrapper?.classList.remove('is-display-active');
            if (projectSelectDisplay) {
                projectSelectDisplay.style.display = 'none';
            }
            if (projectDropdownBackdrop) {
                projectDropdownBackdrop.style.display = 'block';
            }
            projectSelectInput.dataset.previousValue = projectSelectInput.value;
            projectSelectInput.value = '';
            projectSelectInput.placeholder = 'Search...';
            renderProjectOptions('');
        }

        function closeProjectDropdown(restoreSelection = true) {
            if (!projectSelectDropdown || !projectSelectInput) return;
            projectSelectDropdown.style.display = 'none';
            projectSelectDropdown.classList.remove('keyboard-active');
            projectSelectWrapper?.classList.remove('is-open');
            if (projectSelectArrow) {
                projectSelectArrow.textContent = '▾';
            }
            if (projectDropdownBackdrop) {
                projectDropdownBackdrop.style.display = 'none';
            }
            if (restoreSelection) {
                const selectedName = projectSelectInput.dataset.selectedName || '';
                projectSelectInput.value = selectedName;
            }
            projectSelectInput.placeholder = 'Select project…';
            updateProjectSelectionDisplay();
        }

        function getSpecialUploadOptionElements() {
            return specialUploadDropdown
                ? Array.from(specialUploadDropdown.querySelectorAll('.project-option'))
                : [];
        }

        function updateSpecialUploadDisplay() {
            if (!specialUploadDisplay || !specialUploadWrapper || !specialUploadInput) return;
            const selectedName = specialUploadInput.dataset.selectedName || '';
            if (!selectedName) {
                specialUploadDisplay.textContent = '';
                specialUploadDisplay.style.display = 'none';
                specialUploadWrapper.classList.remove('is-display-active');
                return;
            }
            specialUploadDisplay.textContent = selectedName;
            specialUploadDisplay.style.display = 'flex';
            specialUploadWrapper.classList.add('is-display-active');
        }

        function saveSpecialUploadSelection(value, label) {
            if (!storage) return;
            const normalizedValue = value ? String(value) : '';
            const normalizedLabel = label ? String(label) : '';
            try {
                if (!normalizedValue && !normalizedLabel) {
                    storage.removeItem(specialUploadSelectionStorageKey);
                    return;
                }
                storage.setItem(
                    specialUploadSelectionStorageKey,
                    JSON.stringify({ value: normalizedValue, label: normalizedLabel })
                );
            } catch (error) {
                // Ignore storage failures.
            }
        }

        function loadSpecialUploadSelection() {
            if (!storage) return null;
            try {
                const raw = storage.getItem(specialUploadSelectionStorageKey);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return {
                    value: parsed?.value ? String(parsed.value) : '',
                    label: parsed?.label ? String(parsed.label) : '',
                };
            } catch (error) {
                return null;
            }
        }

        function findSpecialUploadOptionByValue(value) {
            const normalizedValue = value ? String(value) : '';
            if (!normalizedValue) return null;
            return specialUploadOptions.find((option) => (
                !option.isEmpty && String(option.value) === normalizedValue
            )) || null;
        }

        function isSemEdxSelected() {
            return specialUploadSelect?.value === 'sem_edx_spectra';
        }

        function evaluateSemEdxFiles(entries) {
            if (!entries.length) {
                return { hasFiles: false, valid: true };
            }
            const groups = new Map();
            entries.forEach((entry) => {
                const rawPath = getEntryPath(entry);
                if (!rawPath) return;
                const parts = rawPath.split('/');
                const fileName = parts.pop() || '';
                const dirKey = parts.join('/');
                if (!groups.has(dirKey)) {
                    groups.set(dirKey, { txt: 0, other: 0 });
                }
                const group = groups.get(dirKey);
                const isTxt = fileName.toLowerCase().endsWith('.txt');
                if (isTxt) {
                    group.txt += 1;
                } else {
                    group.other += 1;
                }
            });
            if (groups.size === 0) {
                return { hasFiles: false, valid: true };
            }
            for (const group of groups.values()) {
                if (group.txt < 1 || group.other < 1) {
                    return { hasFiles: true, valid: false };
                }
            }
            return { hasFiles: true, valid: true };
        }

        function getSemEdxAppendedCount() {
            const associationMap = semEdxAssociationMode === 'manual'
                ? semEdxManualAssociations
                : semEdxAssociationCache;
            return Array.from(associationMap.values()).reduce(
                (total, items) => total + (Array.isArray(items) ? items.length : 0),
                0
            );
        }

        function updateSemEdxStatus() {
            if (!isSemEdxSelected()) {
                updateSemEdxStepControls(false);
                return false;
            }
            const { hasFiles, valid } = evaluateSemEdxFiles(pendingFiles);
            const appendedCount = getSemEdxAppendedCount();
            if (!hasFiles) {
                setStatus('');
                updateSemEdxStepControls(false);
                return true;
            }
            if (semEdxInstructionStep > 1) {
                if (!valid) {
                    setStatus('You need to add at least one image and one txt file in the base path and per folder.\n', 'error');
                    updateSemEdxStepControls(false);
                    return true;
                }
                if (appendedCount < 1) {
                    setStatus('Please append at least one txt filename before proceeding.', 'error');
                    updateSemEdxStepControls(false);
                    return true;
                }
                setStatus('');
                updateSemEdxStepControls(true);
                return true;
            }
            if (valid) {
                setStatus('Files added successfully.', 'success');
            } else {
                setStatus('You need to add at least one image and one txt file in the base path and per folder.\n', 'error');
            }
            updateSemEdxStepControls(valid);
            return true;
        }

        function setSemEdxInstructionLines(lines = []) {
            if (!semEdxInstructions) return;
            const primaryLine = lines[0] || '';
            const secondaryLine = lines[1] || '';
            if (semEdxInstructionPrimary) {
                semEdxInstructionPrimary.textContent = primaryLine;
            }
            if (semEdxInstructionSecondary) {
                semEdxInstructionSecondary.textContent = secondaryLine;
            }
            if (semEdxInstructionSecondaryRow) {
                semEdxInstructionSecondaryRow.classList.toggle('is-visible', Boolean(secondaryLine));
            }
        }

        function setSemEdxInstructionsStep(step) {
            const previousStep = semEdxInstructionStep;
            semEdxInstructionStep = step;
            if (!semEdxInstructions) return;
            const instructionLines = step === 2
                ? semEdxStep2Lines
                : step === 3
                    ? semEdxStep3Lines
                    : semEdxStep1Lines;
            setSemEdxInstructionLines(instructionLines);
            if (step > 1 && previousStep <= 1) {
                semEdxExpandedNodes.clear();
                semEdxExpandedNodesInitialized = false;
            }
            if (step <= 1) {
                semEdxExpandedNodes.clear();
                semEdxExpandedNodesInitialized = false;
            }
            refreshFileList();
            updateSemEdxStepControls(step > 1);
            updateUploadControlAvailability();
            if (uploadCard) {
                uploadCard.classList.toggle('sem-edx-step-two', isSemEdxSelected() && step > 1);
                uploadCard.classList.toggle('sem-edx-step-three', isSemEdxSelected() && step > 2);
            }
        }

        function updateSemEdxIntroVisibility() {
            if (!uploadIntroText) return;
            const shouldHide = isSemEdxSelected() && semEdxInstructionStep > 1;
            uploadIntroText.style.visibility = shouldHide ? 'hidden' : 'visible';
        }

        function updateSemEdxStepControls(isSemEdxReady) {
            const isActive = isSemEdxSelected();
            if (nextStepBtn) {
                const shouldShowNext = isActive && (semEdxInstructionStep > 1 || isSemEdxReady);
                nextStepBtn.classList.toggle('is-hidden', !shouldShowNext);
                nextStepBtn.disabled = isActive && semEdxInstructionStep > 1 && !isSemEdxReady;
            }
            if (previousStepBtn) {
                const shouldShowPrevious = isActive && semEdxInstructionStep > 1;
                previousStepBtn.classList.toggle('is-hidden', !shouldShowPrevious);
            }
            updateSemEdxIntroVisibility();
        }

        function setProjectSelectionVisibility(show) {
            const shouldShow = !!show;
            if (projectSelectRow) {
                projectSelectRow.style.visibility = shouldShow ? 'visible' : 'hidden';
                projectSelectRow.style.pointerEvents = shouldShow ? '' : 'none';
            }
            if (projectSelectGroup) {
                projectSelectGroup.style.visibility = shouldShow ? 'visible' : 'hidden';
                projectSelectGroup.style.pointerEvents = shouldShow ? '' : 'none';
            }
            if (projectSelectInput) {
                projectSelectInput.disabled = !shouldShow;
            }
            if (projectSelect) {
                projectSelect.disabled = !shouldShow;
            }
            if (projectRefreshBtn) {
                projectRefreshBtn.disabled = !shouldShow;
            }
            if (!shouldShow) {
                closeProjectDropdown(false);
            }
        }

        function setSemEdxAssociationMode(mode) {
            semEdxAssociationMode = mode === 'manual' ? 'manual' : 'automatic';
            refreshFileList();
        }

        function applySpecialUploadMode(value, options = {}) {
            const { isInitial = false } = options;
            const isSemEdx = value === 'sem_edx_spectra';
            const shouldHideProjectSelection = !!value;
            document.documentElement.classList.toggle('special-upload-active', shouldHideProjectSelection);
            if (document.body) {
                document.body.classList.toggle('special-upload-active', shouldHideProjectSelection);
            }
            if (semEdxInstructions) {
                semEdxInstructions.style.display = isSemEdx ? 'flex' : 'none';
            }
            if (uploadBtn) {
                uploadBtn.classList.toggle('action-btn-hidden', !!value);
            }
            if (!value) {
                semEdxInstructionStep = 1;
                setSemEdxInstructionsStep(1);
                updateSemEdxStepControls(false);
            }
            setProjectSelectionVisibility(!value);
            if (isSemEdx) {
                semEdxModeActive = true;
                setSemEdxInstructionsStep(1);
                setSemEdxAssociationMode('automatic');
            } else {
                resetSemEdxSettingsDraft();
                if (semEdxModeActive) {
                    clearSelectedFiles();
                }
                semEdxModeActive = false;
                setStatus('');
                updateSemEdxStepControls(false);
            }
            updateSemEdxStatus();
        }

        function setSpecialUploadSelection(value, label, options = {}) {
            const { persist = true, modeOptions = {} } = options;
            if (!specialMethodsEnabled && value) {
                clearSpecialUploadSelection({ persist });
                return;
            }
            if (specialUploadSelect) {
                specialUploadSelect.value = value || '';
            }
            if (specialUploadInput) {
                specialUploadInput.value = label || '';
                specialUploadInput.dataset.selectedName = label || '';
            }
            updateSpecialUploadDisplay();
            applySpecialUploadMode(value, modeOptions);
            if (persist) {
                saveSpecialUploadSelection(value, label);
            }
        }

        function clearSpecialUploadSelection(options = {}) {
            const { persist = true } = options;
            if (specialUploadSelect) {
                specialUploadSelect.value = '';
            }
            if (specialUploadInput) {
                specialUploadInput.value = '';
                specialUploadInput.dataset.selectedName = '';
            }
            updateSpecialUploadDisplay();
            applySpecialUploadMode('');
            if (persist) {
                saveSpecialUploadSelection('', '');
            }
        }

        function restoreSpecialUploadSelection() {
            if (!specialMethodsEnabled) {
                clearSpecialUploadSelection({ persist: false });
                return;
            }
            const stored = loadSpecialUploadSelection();
            if (!stored) return;
            if (!stored.value) {
                clearSpecialUploadSelection({ persist: false });
                return;
            }
            const match = findSpecialUploadOptionByValue(stored.value);
            if (!match) {
                clearSpecialUploadSelection({ persist: false });
                saveSpecialUploadSelection('', '');
                return;
            }
            const label = stored.label || match.label;
            setSpecialUploadSelection(match.value, label, { persist: false, modeOptions: { isInitial: true } });
        }

        function renderSpecialUploadOptions(query = '') {
            if (!specialUploadDropdown) return;
            const normalizedQuery = String(query || '').trim().toLowerCase();
            specialUploadDropdown.innerHTML = '';
            const matches = specialUploadOptions.filter((option) => {
                if (!normalizedQuery) return true;
                if (option.isEmpty) return false;
                return option.label.toLowerCase().includes(normalizedQuery);
            });
            if (matches.length === 0) {
                const emptyOption = document.createElement('div');
                emptyOption.className = 'project-option is-empty';
                emptyOption.dataset.disabled = 'true';
                emptyOption.textContent = 'No matches';
                specialUploadDropdown.appendChild(emptyOption);
                return;
            }
            matches.forEach((option) => {
                const optionEl = document.createElement('div');
                optionEl.className = `project-option${option.isEmpty ? ' is-empty' : ''}`;
                optionEl.dataset.value = option.value;
                optionEl.dataset.label = option.label;
                optionEl.textContent = option.label;
                specialUploadDropdown.appendChild(optionEl);
            });
        }

        function setActiveSpecialUploadIndex(index, useKeyboard = false) {
            const options = getSpecialUploadOptionElements();
            if (options.length === 0) {
                activeSpecialUploadIndex = -1;
                return;
            }
            if (specialUploadDropdown) {
                if (useKeyboard) {
                    specialUploadDropdown.classList.add('keyboard-active');
                } else {
                    specialUploadDropdown.classList.remove('keyboard-active');
                }
            }
            const clampedIndex = Math.max(0, Math.min(index, options.length - 1));
            activeSpecialUploadIndex = clampedIndex;
            options.forEach((option, optionIndex) => {
                option.classList.toggle('is-active', optionIndex === clampedIndex);
            });
            if (useKeyboard) {
                options[clampedIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectSpecialUploadOption(optionEl) {
            if (optionEl?.dataset?.disabled === 'true') {
                return;
            }
            if (!optionEl || optionEl.classList.contains('is-empty')) {
                clearSpecialUploadSelection();
                closeSpecialUploadDropdown(true);
                return;
            }
            const value = optionEl.dataset.value || '';
            const label = optionEl.dataset.label || optionEl.textContent || '';
            if (!value) {
                clearSpecialUploadSelection();
            } else {
                setSpecialUploadSelection(value, label);
            }
            closeSpecialUploadDropdown(true);
        }

        function openSpecialUploadDropdown() {
            if (!specialUploadDropdown || !specialUploadInput) return;
            closeProjectDropdown(false);
            specialUploadDropdown.style.display = 'block';
            specialUploadDropdown.classList.remove('keyboard-active');
            specialUploadWrapper?.classList.add('is-open');
            if (specialUploadArrow) {
                specialUploadArrow.textContent = '▴';
            }
            specialUploadWrapper?.classList.remove('is-display-active');
            if (specialUploadDisplay) {
                specialUploadDisplay.style.display = 'none';
            }
            if (projectDropdownBackdrop) {
                projectDropdownBackdrop.style.display = 'block';
            }
            specialUploadInput.dataset.previousValue = specialUploadInput.value;
            specialUploadInput.value = '';
            specialUploadInput.placeholder = 'Search...';
            activeSpecialUploadIndex = -1;
            renderSpecialUploadOptions('');
        }

        function closeSpecialUploadDropdown(restoreSelection = true) {
            if (!specialUploadDropdown || !specialUploadInput) return;
            specialUploadDropdown.style.display = 'none';
            specialUploadDropdown.classList.remove('keyboard-active');
            specialUploadWrapper?.classList.remove('is-open');
            if (specialUploadArrow) {
                specialUploadArrow.textContent = '▾';
            }
            if (projectDropdownBackdrop) {
                projectDropdownBackdrop.style.display = 'none';
            }
            if (restoreSelection) {
                const selectedName = specialUploadInput.dataset.selectedName || '';
                specialUploadInput.value = selectedName;
            }
            specialUploadInput.placeholder = 'Select a special method...';
            updateSpecialUploadDisplay();
        }

        function filterSpecialUploadOptions(query) {
            renderSpecialUploadOptions(query);
        }

        function filterProjectOptions(query) {
            if (projectFilterTimeout) {
                window.clearTimeout(projectFilterTimeout);
            }
            projectFilterTimeout = window.setTimeout(() => {
                renderProjectOptions(query);
            }, 120);
        }

        function formatBytes(bytes) {
            if (!bytes) return '0 B';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let value = bytes;
            let unitIndex = 0;
            while (value >= 1024 && unitIndex < units.length - 1) {
                value /= 1024;
                unitIndex += 1;
            }
            return `${value.toFixed(1)} ${units[unitIndex]}`;
        }

        function formatDateTime(timestamp) {
            if (!timestamp) {
                return '—';
            }
            const date = new Date(timestamp);
            return date.toLocaleString(undefined, {
                year: 'numeric',
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
            });
        }

        const uploadBatchFiles = Number({{ upload_batch_files|default:"5"|safe }}) || 5;
        const uploadConcurrency = Number({{ upload_concurrency|default:"3"|safe }}) || 3;
        const uploadRequestTimeoutMs = 2 * 60 * 60 * 1000;
        let currentUploadBatchFiles = uploadBatchFiles;
        const userSettingsDefaults = {
            uploadBatchFiles,
            showAllProjects: false,
            removeClearAll: false,
        };
        const csrfTokenName = 'csrftoken';

        function getCookie(name) {
            if (!document.cookie || typeof name !== 'string' || !name) {
                return null;
            }
            // Escape special regex characters
            const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const pattern = new RegExp(`(?:^|;\\s*)${escapedName}=([^;]*)`);
            const match = document.cookie.match(pattern);
            if (match) {
                try {
                    return decodeURIComponent(match[1]);
                } catch (error) {
                    console.warn('Failed to decode cookie:', error);
                    return match[1];
                }
            }
            return null;
        }

        function getCsrfToken() {
            return getCookie(csrfTokenName);
        }

        function setRequestHeaders(headers, target) {
            const csrfToken = getCsrfToken();
            if (csrfToken) {
                headers['X-CSRFToken'] = csrfToken;
            }
            headers['X-Requested-With'] = 'XMLHttpRequest';
            if (target && typeof target.setRequestHeader === 'function') {
                Object.entries(headers).forEach(([key, value]) => {
                    target.setRequestHeader(key, value);
                });
            }
            return headers;
        }

        function setProgressStage(text) {
            if (progressStage) {
                progressStage.textContent = text;
            }
        }

        function updateProgress(percent, text) {
            progressBar.style.width = `${percent}%`;
            progressBar.textContent = `${percent}%`;
            progressText.textContent = text;
        }

        function showNonBlockingModal(message) {
            const overlay = document.getElementById('nb-modal-overlay');
            const msg = document.getElementById('nb-modal-message');
            const okBtn = document.getElementById('nb-modal-ok');
            if (msg) msg.innerText = message;
            if (overlay) overlay.style.display = 'flex';
            if (okBtn) {
                window.requestAnimationFrame(() => {
                    okBtn.focus();
                });
            }
        }

        function hideNonBlockingModal() {
            const overlay = document.getElementById('nb-modal-overlay');
            if (overlay) overlay.style.display = 'none';
        }

        function setUserSettingsStatus(message, isError = false) {
            if (!userSettingsStatus) return;
            userSettingsStatus.textContent = message || '';
            userSettingsStatus.style.color = isError ? '#b91c1c' : '#1f2937';
        }

        function setUserSettingError(input, hasError) {
            if (!input) return;
            input.classList.toggle('user-setting-error', hasError);
        }

        function clearUserSettingErrors() {
            setUserSettingError(userSettingsBatchInput, false);
            setUserSettingsStatus('');
        }

        function loadUserSettings() {
            if (!storage) return null;
            try {
                const raw = storage.getItem(userSettingsStorageKey);
                if (!raw) return null;
                return JSON.parse(raw);
            } catch (error) {
                return null;
            }
        }

        function applyShowAllProjectsSetting(enabled, { refresh = true } = {}) {
            showAllProjectsEnabled = !!enabled;
            if (userSettingShowAllYes && userSettingShowAllNo) {
                userSettingShowAllYes.checked = showAllProjectsEnabled;
                userSettingShowAllNo.checked = !showAllProjectsEnabled;
            }
            if (refresh && projectSelectDropdown?.style.display === 'block') {
                renderProjectOptions(projectSelectInput?.value || '');
            }
        }

        function applyClearAllSetting(enabled) {
            const removeClearAll = !!enabled;
            if (userSettingRemoveClearAllYes && userSettingRemoveClearAllNo) {
                userSettingRemoveClearAllYes.checked = removeClearAll;
                userSettingRemoveClearAllNo.checked = !removeClearAll;
            }
            if (clearAllBtn) {
                clearAllBtn.disabled = removeClearAll;
                clearAllBtn.classList.toggle('action-btn-hidden', removeClearAll);

                if (removeClearAll) {
                    clearAllBtn.style.opacity = '0';
                    clearAllBtn.style.visibility = 'hidden';
                    clearAllBtn.style.pointerEvents = 'none';
                } else {
                    clearAllBtn.style.opacity = '1';
                    clearAllBtn.style.visibility = 'visible';
                    clearAllBtn.style.pointerEvents = 'auto';
                }
            }
        }

        function applyUserSettings(settings) {
            const batchSize = settings?.uploadBatchFiles;
            if (Number.isInteger(batchSize)) {
                currentUploadBatchFiles = batchSize;
            }
            if (userSettingsBatchInput) {
                userSettingsBatchInput.value = `${currentUploadBatchFiles}`;
            }
            applyShowAllProjectsSetting(settings?.showAllProjects, { refresh: false });
            applyClearAllSetting(settings?.removeClearAll);
        }

        function resetUserSettingsToDefaults() {
            currentUploadBatchFiles = userSettingsDefaults.uploadBatchFiles;
            if (userSettingsBatchInput) {
                userSettingsBatchInput.value = `${currentUploadBatchFiles}`;
            }
            applyShowAllProjectsSetting(userSettingsDefaults.showAllProjects, { refresh: false });
            applyClearAllSetting(userSettingsDefaults.removeClearAll);
            clearUserSettingErrors();
        }

        function populateUserSettings() {
            const stored = loadUserSettings();
            if (stored) {
                applyUserSettings(stored);
                return;
            }
            resetUserSettingsToDefaults();
        }

        function validateUserSettings() {
            const rawValue = userSettingsBatchInput?.value?.trim() ?? '';
            const numericPattern = /^\d+$/;
            const value = numericPattern.test(rawValue) ? parseInt(rawValue, 10) : NaN;
            const isValid = Number.isInteger(value) && value >= 1 && value <= 10;
            setUserSettingError(userSettingsBatchInput, !isValid);
            const showAllProjects = !!userSettingShowAllYes?.checked;
            const removeClearAll = !!userSettingRemoveClearAllYes?.checked;
            if (!isValid) {
                showNonBlockingModal(messages.formattingErrors);
                return null;
            }
            return { uploadBatchFiles: value, showAllProjects, removeClearAll };
        }

        function saveUserSettingsToDatabase(settings, options = {}) {
            const { showSuccessMessage = true, onSuccess, onError } = options;
            return fetch(userSettingsSaveUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ settings }),
            })
                .then((resp) => resp.json())
                .then((data) => {
                    if (data.error) {
                        showNonBlockingModal(data.error);
                        if (typeof onError === 'function') {
                            onError(data.error);
                        }
                        return false;
                    }

                    if (showSuccessMessage) {
                        showNonBlockingModal(messages.userSettingsSavedDb);
                    }

                    const saveSucceeded =
                        (data && typeof data.success === 'boolean')
                            ? data.success === true
                            : true;

                    if (saveSucceeded && data && data.settings) {
                        applyUserSettings(data.settings);
                    }

                    if (typeof onSuccess === 'function') {
                        onSuccess(data);
                    }
                    return true;
                })
                .catch((err) => {
                    showNonBlockingModal(formatMessage(messages.userSettingsSaveError, { error: err }));
                    if (typeof onError === 'function') {
                        onError(err);
                    }
                    return false;
                });
        }

        function openUserSettingsModal() {
            if (!userSettingsOverlay) return;
            userSettingsOverlay.style.display = 'flex';
            userSettingsOverlay.setAttribute('aria-hidden', 'false');
        }

        function closeUserSettingsModal() {
            if (!userSettingsOverlay) return;
            userSettingsOverlay.style.display = 'none';
            userSettingsOverlay.setAttribute('aria-hidden', 'true');
            clearUserSettingErrors();
        }

        function clearSelectedFiles() {
            pendingFiles = [];
            expandedNodes.clear();
            fileInput.value = '';
            folderInput.value = '';
            invalidateSemEdxAssociations();
            refreshFileList();
            updateSemEdxStatus();
        }

        function buildTree(entries) {
            const root = {
                name: '',
                children: new Map(),
                files: [],
                totalSize: 0,
                totalFiles: 0,
                lastModified: 0,
                hasIncompatible: false,
            };
            entries.forEach((entry) => {
                const rawPath = getEntryPath(entry);
                const parts = rawPath.split('/').filter(Boolean);
                let node = root;
                parts.forEach((part, index) => {
                    const isFile = index === parts.length - 1;
                    if (isFile) {
                        node.files.push({
                            name: part,
                            size: entry.file.size,
                            rawPath,
                            lastModified: entry.file.lastModified,
                            entry: entry,
                        });
                        return;
                    }
                    if (!node.children.has(part)) {
                        node.children.set(part, {
                            name: part,
                            children: new Map(),
                            files: [],
                            totalSize: 0,
                            lastModified: 0,
                            hasIncompatible: false,
                        });
                    }
                    node = node.children.get(part);
                });
            });
            return computeNodeStats(root);
        }

        function computeNodeStats(node) {
            let totalSize = 0;
            let totalFiles = 0;
            let latest = 0;
            let hasIncompatible = false;
            
            node.files.forEach((file) => {
                totalSize += file.size;
                totalFiles += 1;
                latest = Math.max(latest, file.lastModified || 0);
                if (file.entry?.isIncompatible) {
                    hasIncompatible = true;
                }
            });
            
            node.children.forEach((child) => {
                const updatedChild = computeNodeStats(child);
                totalSize += updatedChild.totalSize;
                totalFiles += updatedChild.totalFiles;
                latest = Math.max(latest, updatedChild.lastModified || 0);
                if (updatedChild.hasIncompatible) {
                    hasIncompatible = true;
                }
            });
            
            node.totalSize = totalSize;
            node.totalFiles = totalFiles;
            node.lastModified = latest;
            node.hasIncompatible = hasIncompatible;
            return node;
        }
        
        function createIcon(kind) {
            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            icon.setAttribute('viewBox', '0 0 24 24');
            icon.classList.add('tree-icon');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            if (kind === 'folder') {
                path.setAttribute(
                    'd',
                    'M10 4l2 2h8a2 2 0 012 2v9a3 3 0 01-3 3H5a3 3 0 01-3-3V6a2 2 0 012-2h6z'
                );
                path.setAttribute('fill', '#f59e0b');
            } else {
                path.setAttribute('d', 'M6 3h9l5 5v12a2 2 0 01-2 2H6a2 2 0 01-2-2V5a2 2 0 012-2z');
                path.setAttribute('fill', '#94a3b8');
            }
            icon.appendChild(path);
            return icon;
        }

        function removeByPredicate(predicate) {
            pendingFiles = pendingFiles.filter((entry) => !predicate(entry));
            if (!pendingFiles.length) {
                fileInput.value = '';
                folderInput.value = '';
                expandedNodes.clear();
            }
            invalidateSemEdxAssociations();
            refreshFileList();
            updateSemEdxStatus();
        }

        function removeFileEntry(rawPath) {
            removeByPredicate((entry) => getEntryPath(entry) === rawPath);
        }

        function removeFolderEntries(folderPath, isRootGroup) {
            if (isRootGroup) {
                removeByPredicate((entry) => !getEntryPath(entry).includes('/'));
                expandedNodes.clear();
                return;
            }
            expandedNodes.forEach((path) => {
                if (path.startsWith(folderPath)) {
                    expandedNodes.delete(path);
                }
            });
            removeByPredicate((entry) => getEntryPath(entry).startsWith(folderPath));
        }

        function renderTree(node, depth = 0, pathPrefix = '') {
            const list = document.createElement('ul');
            node.children.forEach((child) => {
                const item = document.createElement('li');
                item.classList.add('tree-node');

                const row = document.createElement('div');
                row.classList.add('tree-row');
                row.style.setProperty('--depth', depth);
                
                if (child.hasIncompatible) {
                    row.classList.add('is-incompatible-folder');
                }

                const nameCell = document.createElement('div');
                nameCell.classList.add('tree-name-cell');

                const toggle = document.createElement('button');
                toggle.type = 'button';
                toggle.classList.add('tree-toggle');
                toggle.textContent = '▸';
                toggle.setAttribute('aria-expanded', 'false');
                toggle.setAttribute('aria-label', `Expand ${child.name}`);

                const icon = createIcon('folder');
                const label = document.createElement('span');
                label.classList.add('tree-name');
                label.textContent = child.name;

                const itemCount = child.totalFiles;
                const meta = document.createElement('span');
                meta.classList.add('tree-meta');
                meta.textContent = `${itemCount} file${itemCount === 1 ? '' : 's'}`;

                const size = document.createElement('span');
                size.classList.add('tree-size');
                size.textContent = formatBytes(child.totalSize);

                const date = document.createElement('span');
                date.classList.add('tree-date');
                date.textContent = formatDateTime(child.lastModified);

                nameCell.appendChild(toggle);
                nameCell.appendChild(icon);
                nameCell.appendChild(label);
                nameCell.appendChild(meta);

                row.appendChild(nameCell);
                row.appendChild(size);
                row.appendChild(date);
                const deleteCell = document.createElement('div');
                deleteCell.classList.add('tree-delete-cell');
                const deleteButton = document.createElement('button');
                deleteButton.type = 'button';
                deleteButton.classList.add('var-row-btn', 'var-row-remove');
                deleteButton.setAttribute('aria-label', `Remove ${child.name}`);
                deleteButton.textContent = '−';
                const folderPath = child.isRootGroup ? '' : `${pathPrefix}${child.name}/`;
                const isExpanded = expandedNodes.has(folderPath);
                deleteButton.addEventListener('click', () => {
                    removeFolderEntries(folderPath, Boolean(child.isRootGroup));
                });
                deleteCell.appendChild(deleteButton);
                row.appendChild(deleteCell);

                const childrenList = renderTree(child, depth + 1, folderPath);
                childrenList.classList.add('tree-children');
                childrenList.hidden = !isExpanded;
                toggle.setAttribute('aria-expanded', String(isExpanded));
                toggle.textContent = isExpanded ? '▾' : '▸';

                toggle.addEventListener('click', () => {
                    const expanded = toggle.getAttribute('aria-expanded') === 'true';
                    toggle.setAttribute('aria-expanded', String(!expanded));
                    toggle.textContent = expanded ? '▸' : '▾';
                    toggle.setAttribute('aria-label', `${expanded ? 'Expand' : 'Collapse'} ${child.name}`);
                    childrenList.hidden = expanded;
                    if (expanded) {
                        expandedNodes.delete(folderPath);
                    } else {
                        expandedNodes.add(folderPath);
                    }
                });

                item.appendChild(row);
                item.appendChild(childrenList);
                list.appendChild(item);
            });
            
            node.files
                .sort((a, b) => a.name.localeCompare(b.name))
                .forEach((file) => {
                    const item = document.createElement('li');
                    item.classList.add('tree-node');
                    const row = document.createElement('div');
                    row.classList.add('tree-row');
                    row.style.setProperty('--depth', depth);
                    
                    if (file.entry?.isIncompatible) {
                        row.classList.add('is-incompatible');
                    }

                    const nameCell = document.createElement('div');
                    nameCell.classList.add('tree-name-cell');

                    const spacer = document.createElement('span');
                    spacer.classList.add('tree-spacer');

                    const icon = createIcon('file');
                    const label = document.createElement('span');
                    label.classList.add('tree-file-name');
                    label.textContent = file.name;
                    
                    const size = document.createElement('span');
                    size.classList.add('tree-size');
                    size.textContent = formatBytes(file.size);

                    const date = document.createElement('span');
                    date.classList.add('tree-date');
                    date.textContent = formatDateTime(file.lastModified);
                    
                    const deleteCell = document.createElement('div');
                    deleteCell.classList.add('tree-delete-cell');
                    const deleteButton = document.createElement('button');
                    deleteButton.type = 'button';
                    deleteButton.classList.add('var-row-btn', 'var-row-remove');
                    deleteButton.setAttribute('aria-label', `Remove ${file.name}`);
                    deleteButton.textContent = '−';
                    deleteButton.addEventListener('click', () => {
                        removeFileEntry(file.rawPath);
                    });
                    deleteCell.appendChild(deleteButton);

                    nameCell.appendChild(spacer);
                    nameCell.appendChild(icon);
                    nameCell.appendChild(label);
                    row.appendChild(nameCell);
                    row.appendChild(size);
                    row.appendChild(date);
                    row.appendChild(deleteCell);
                    item.appendChild(row);
                    list.appendChild(item);
                });
            
            return list;
        }

        function isSemEdxTxtEntry(entry) {
            const rawPath = getEntryPath(entry);
            if (!rawPath) return false;
            const name = rawPath.split('/').pop() || '';
            return name.toLowerCase().endsWith('.txt');
        }

        function getSemEdxImageEntries(entries) {
            return entries.filter((entry) => !isSemEdxTxtEntry(entry));
        }

        function getSemEdxTxtEntries(entries) {
            return entries.filter((entry) => isSemEdxTxtEntry(entry));
        }

        function getSemEdxDirectory(rawPath) {
            const parts = String(rawPath || '').split('/');
            parts.pop();
            return parts.join('/');
        }

        function buildSemEdxTxtLookup(entries) {
            const groups = groupSemEdxEntries(entries);
            const lookup = new Map();
            groups.forEach((group, directory) => {
                const names = group.txt
                    .map((txt) => txt.fileName)
                    .filter(Boolean)
                    .sort((a, b) => a.localeCompare(b));
                lookup.set(directory, names);
            });
            return lookup;
        }

        function buildSemEdxAssociationPayload(entries) {
            const associations = semEdxAssociationMode === 'manual'
                ? semEdxManualAssociations
                : semEdxAssociationCache;
            if (semEdxAssociationMode === 'manual') {
                ensureSemEdxManualAssociations(semEdxAssociationCache);
            }
            const groups = groupSemEdxEntries(entries);
            const txtLookup = new Map();
            groups.forEach((group, directory) => {
                const map = new Map();
                group.txt.forEach((txt) => {
                    if (txt.fileName && txt.rawPath) {
                        map.set(txt.fileName, txt.rawPath);
                    }
                });
                txtLookup.set(directory, map);
            });
            const payload = {};
            associations.forEach((txtFiles, imageRawPath) => {
                if (!Array.isArray(txtFiles) || !txtFiles.length) {
                    return;
                }
                const normalizedImage = normalizeCompatibilityPath(imageRawPath);
                if (!normalizedImage) {
                    return;
                }
                const directory = getSemEdxDirectory(imageRawPath);
                const directoryLookup = txtLookup.get(directory) || new Map();
                const mapped = txtFiles
                    .map((name) => directoryLookup.get(name))
                    .filter(Boolean)
                    .map((path) => normalizeCompatibilityPath(path));
                if (mapped.length) {
                    payload[normalizedImage] = mapped;
                }
            });
            return payload;
        }

        function stripSemEdxExtension(name) {
            return String(name || '').replace(/\.[^/.]+$/, '');
        }

        function normalizeSemEdxName(name) {
            return stripSemEdxExtension(name)
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, ' ')
                .trim();
        }

        function extractSemEdxStem(name, type = 'generic') {
            const normalized = normalizeSemEdxName(name);
            if (!normalized) return '';
            if (type === 'txt') {
                return normalized.replace(/\bspectrum\b.*$/, '').trim();
            }
            if (type === 'image') {
                return normalized
                    .replace(/\belectron\b.*$/, '')
                    .replace(/\bimage\b.*$/, '')
                    .replace(/\bsig\b.*$/, '')
                    .trim();
            }
            return normalized;
        }

        function extractSemEdxSpectrumNumber(value) {
            if (!value) return null;
            const match = String(value).match(/spect(?:rum|um)\s*([0-9]+)/i);
            return match ? match[1] : null;
        }

        function parseSemEdxTxtContent(content) {
            const lines = String(content || '').split(/\r?\n/);
            let title = '';
            let spectrumData = [];
            let inSpectrum = false;
            lines.forEach((line) => {
                if (!inSpectrum) {
                    if (line.startsWith('#TITLE')) {
                        const parts = line.split(':');
                        title = parts.slice(1).join(':').trim();
                    }
                    if (line.startsWith('#SPECTRUM')) {
                        inSpectrum = true;
                    }
                    return;
                }
                if (line.startsWith('#END')) {
                    inSpectrum = false;
                    return;
                }
                const match = line.match(/^\s*([+-]?\d*\.?\d+)\s*,\s*([+-]?\d*\.?\d+)/);
                if (match) {
                    spectrumData.push({
                        x: Number.parseFloat(match[1]),
                        y: Number.parseFloat(match[2]),
                    });
                }
            });
            return { title, spectrumData };
        }

        async function loadSemEdxTxtData(entries) {
            const parsed = new Map();
            await Promise.all(entries.map(async (entry) => {
                const rawPath = getEntryPath(entry);
                if (!rawPath) return;
                if (semEdxTxtCache.has(rawPath)) {
                    parsed.set(rawPath, semEdxTxtCache.get(rawPath));
                    return;
                }
                try {
                    const content = await entry.file.text();
                    const data = parseSemEdxTxtContent(content);
                    semEdxTxtCache.set(rawPath, data);
                    parsed.set(rawPath, data);
                } catch (error) {
                    semEdxTxtCache.set(rawPath, { title: '', spectrumData: [] });
                    parsed.set(rawPath, { title: '', spectrumData: [] });
                }
            }));
            return parsed;
        }

        function groupSemEdxEntries(entries) {
            const groups = new Map();
            entries.forEach((entry) => {
                const rawPath = getEntryPath(entry);
                if (!rawPath) return;
                const parts = rawPath.split('/');
                const fileName = parts.pop() || '';
                const directory = parts.join('/');
                const isTxt = fileName.toLowerCase().endsWith('.txt');
                if (!groups.has(directory)) {
                    groups.set(directory, { images: [], txt: [] });
                }
                const info = {
                    entry,
                    rawPath,
                    fileName,
                    baseName: stripSemEdxExtension(fileName),
                    normalizedName: normalizeSemEdxName(fileName),
                    spectrumNumber: extractSemEdxSpectrumNumber(fileName),
                };
                if (isTxt) {
                    groups.get(directory).txt.push(info);
                } else {
                    groups.get(directory).images.push(info);
                }
            });
            return groups;
        }

        async function buildSemEdxAutomaticAssociations(entries) {
            const associations = new Map();
            const txtEntries = getSemEdxTxtEntries(entries);
            const txtDataMap = await loadSemEdxTxtData(txtEntries);
            const groups = groupSemEdxEntries(entries);

            const addAssociation = (imageRawPath, txtFileName) => {
                if (!imageRawPath || !txtFileName) return;
                const existing = associations.get(imageRawPath) || [];
                if (!existing.includes(txtFileName)) {
                    associations.set(imageRawPath, [...existing, txtFileName]);
                }
            };

            groups.forEach((group) => {
                const images = group.images;
                const txtFiles = group.txt;
                if (!images.length || !txtFiles.length) return;

                if (images.length === 1 && txtFiles.length === 1) {
                    associations.set(images[0].rawPath, [txtFiles[0].fileName]);
                    return;
                }

                if (images.length === 1 && txtFiles.length > 1) {
                    associations.set(images[0].rawPath, txtFiles.map((txt) => txt.fileName));
                    return;
                }

                const matchedTxt = new Set();

                const imageLookup = new Map();
                images.forEach((image) => {
                    const key = image.baseName.toLowerCase();
                    if (!imageLookup.has(key)) {
                        imageLookup.set(key, []);
                    }
                    imageLookup.get(key).push(image);
                });

                txtFiles.forEach((txt) => {
                    const matches = imageLookup.get(txt.baseName.toLowerCase()) || [];
                    if (matches.length === 1) {
                        addAssociation(matches[0].rawPath, txt.fileName);
                        matchedTxt.add(txt.rawPath);
                    }
                });

                const imageStemLookup = new Map();
                images.forEach((image) => {
                    const key = extractSemEdxStem(image.fileName, 'image');
                    if (!key) return;
                    if (!imageStemLookup.has(key)) {
                        imageStemLookup.set(key, []);
                    }
                    imageStemLookup.get(key).push(image);
                });

                txtFiles.forEach((txt) => {
                    if (matchedTxt.has(txt.rawPath)) return;
                    const txtData = txtDataMap.get(txt.rawPath);
                    const candidates = [
                        extractSemEdxStem(txt.fileName, 'txt'),
                        extractSemEdxStem(txtData?.title || '', 'txt'),
                    ].filter(Boolean);
                    for (const candidate of candidates) {
                        const matches = imageStemLookup.get(candidate) || [];
                        if (matches.length === 1) {
                            addAssociation(matches[0].rawPath, txt.fileName);
                            matchedTxt.add(txt.rawPath);
                            break;
                        }
                    }
                });

                txtFiles.forEach((txt) => {
                    if (matchedTxt.has(txt.rawPath)) return;
                    const txtData = txtDataMap.get(txt.rawPath);
                    const spectrumNumber = extractSemEdxSpectrumNumber(txtData?.title || '') || txt.spectrumNumber;
                    if (!spectrumNumber) return;
                    const matches = images.filter((image) => (
                        image.spectrumNumber === spectrumNumber
                            || extractSemEdxSpectrumNumber(image.fileName) === spectrumNumber
                    ));
                    if (matches.length === 1) {
                        addAssociation(matches[0].rawPath, txt.fileName);
                        matchedTxt.add(txt.rawPath);
                    }
                });

                txtFiles.forEach((txt) => {
                    if (matchedTxt.has(txt.rawPath)) return;
                    const txtData = txtDataMap.get(txt.rawPath);
                    const candidates = [
                        normalizeSemEdxName(txt.fileName),
                        normalizeSemEdxName(txtData?.title || ''),
                    ].filter(Boolean);
                    const matches = [];
                    images.forEach((image) => {
                        const imageName = image.normalizedName;
                        if (!imageName) return;
                        const isMatch = candidates.some((candidate) => (
                            candidate && (imageName.includes(candidate) || candidate.includes(imageName))
                        ));
                        if (isMatch) {
                            matches.push(image);
                        }
                    });
                    if (matches.length === 1) {
                        addAssociation(matches[0].rawPath, txt.fileName);
                        matchedTxt.add(txt.rawPath);
                    }
                });
            });

            return associations;
        }

        function ensureSemEdxManualAssociations(baseAssociations) {
            if (semEdxManualInitialized) return;
            if (!baseAssociations || baseAssociations.size === 0) return;
            semEdxManualAssociations.clear();
            baseAssociations.forEach((value, key) => {
                semEdxManualAssociations.set(key, [...value]);
            });
            semEdxManualInitialized = true;
            saveSemEdxAssociationsToStorage();
        }

        function updateSemEdxManualAssociations(imagePath, nextList) {
            const unique = [];
            (nextList || []).forEach((item) => {
                if (!item || unique.includes(item)) return;
                unique.push(item);
            });
            if (unique.length) {
                semEdxManualAssociations.set(imagePath, unique);
            } else {
                semEdxManualAssociations.delete(imagePath);
            }
            semEdxManualInitialized = true;
            saveSemEdxAssociationsToStorage();
        }

        function pruneSemEdxManualAssociations(entries) {
            const imageSet = new Set(
                getSemEdxImageEntries(entries).map((entry) => getEntryPath(entry)).filter(Boolean)
            );
            const txtLookup = buildSemEdxTxtLookup(entries);
            const pruneMap = (map) => {
                map.forEach((items, imagePath) => {
                    if (!imageSet.has(imagePath)) {
                        map.delete(imagePath);
                        return;
                    }
                    const directory = getSemEdxDirectory(imagePath);
                    const available = txtLookup.get(directory) || [];
                    const filtered = items.filter((item) => available.includes(item));
                    if (filtered.length) {
                        map.set(imagePath, filtered);
                    } else {
                        map.delete(imagePath);
                    }
                });
            };
            pruneMap(semEdxManualAssociations);
        }

        function collectSemEdxFolderPaths(node, pathPrefix = '') {
            const paths = [];
            node.children.forEach((child) => {
                if (child.totalFiles < 1) {
                    return;
                }
                const folderPath = `${pathPrefix}${child.name}/`;
                paths.push(folderPath);
                paths.push(...collectSemEdxFolderPaths(child, folderPath));
            });
            return paths;
        }

        function primeSemEdxExpandedNodes(tree) {
            if (semEdxExpandedNodesInitialized) return;
            collectSemEdxFolderPaths(tree).forEach((path) => {
                semEdxExpandedNodes.add(path);
            });
            semEdxExpandedNodesInitialized = true;
        }

        function invalidateSemEdxAssociations() {
            semEdxAssociationVersion += 1;
            semEdxAssociationCache = new Map();
            semEdxTxtCache.clear();
            semEdxAssociationReady = false;
            pruneSemEdxManualAssociations(pendingFiles);
            saveSemEdxAssociationsToStorage();
        }

        async function ensureSemEdxAutomaticAssociations() {
            if (semEdxAssociationLoading || semEdxAssociationReady) return;
            const version = semEdxAssociationVersion;
            semEdxAssociationLoading = true;
            const associations = await buildSemEdxAutomaticAssociations(pendingFiles);
            if (version !== semEdxAssociationVersion) {
                semEdxAssociationLoading = false;
                return;
            }
            semEdxAssociationCache = associations;
            semEdxAssociationLoading = false;
            semEdxAssociationReady = true;
            saveSemEdxAssociationsToStorage();
            refreshFileList();
        }

        function buildSemEdxTxtSelect(options, selectedValue = '', includeEmpty = false) {
            const select = document.createElement('select');
            select.classList.add('sem-edx-appended-select');
            if (includeEmpty) {
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select txt...';
                select.appendChild(emptyOption);
            }
            options.forEach((optionValue) => {
                const option = document.createElement('option');
                option.value = optionValue;
                option.textContent = optionValue;
                select.appendChild(option);
            });
            select.value = selectedValue || '';
            return select;
        }

        function renderSemEdxAppendedList(imagePath, options = {}) {
            const { associations, mode = 'automatic', txtOptions = [] } = options;
            const list = document.createElement('div');
            list.classList.add('sem-edx-appended-list');

            const selectedItems = associations?.get(imagePath) || [];
            const selectedSet = new Set(selectedItems);

            selectedItems.forEach((itemName, index) => {
                const row = document.createElement('div');
                row.classList.add('sem-edx-appended-row');
                if (mode === 'manual') {
                    const otherSelections = new Set(
                        selectedItems.filter((_, currentIndex) => currentIndex !== index)
                    );
                    const availableOptions = txtOptions.filter((name) => !otherSelections.has(name) || name === itemName);
                    const select = buildSemEdxTxtSelect(availableOptions, itemName, false);
                    select.addEventListener('change', () => {
                        const nextItems = [...selectedItems];
                        nextItems[index] = select.value;
                        updateSemEdxManualAssociations(imagePath, nextItems);
                        refreshFileList();
                    });
                    const removeButton = document.createElement('button');
                    removeButton.type = 'button';
                    removeButton.classList.add('sem-edx-appended-action', 'sem-edx-appended-action--remove');
                    removeButton.setAttribute('aria-label', `Remove ${itemName}`);
                    removeButton.textContent = '−';
                    removeButton.addEventListener('click', () => {
                        const nextItems = selectedItems.filter((_, currentIndex) => currentIndex !== index);
                        updateSemEdxManualAssociations(imagePath, nextItems);
                        refreshFileList();
                    });
                    row.appendChild(select);
                    row.appendChild(removeButton);
                } else {
                    const label = document.createElement('span');
                    label.classList.add('sem-edx-appended-label');
                    label.textContent = itemName;
                    const ghostButton = document.createElement('span');
                    ghostButton.classList.add(
                        'sem-edx-appended-action',
                        'sem-edx-appended-action--remove',
                        'is-ghost'
                    );
                    row.appendChild(label);
                    row.appendChild(ghostButton);
                }
                list.appendChild(row);
            });

            const availableOptions = txtOptions.filter((name) => !selectedSet.has(name));
            if (availableOptions.length > 0) {
                const addRow = document.createElement('div');
                addRow.classList.add('sem-edx-appended-row');
                const addSelect = buildSemEdxTxtSelect(availableOptions, '', true);
                const addButton = document.createElement('button');
                addButton.type = 'button';
                addButton.classList.add('sem-edx-appended-action', 'sem-edx-appended-action--add');
                addButton.setAttribute('aria-label', 'Append txt');
                addButton.textContent = '+';
                if (mode === 'manual') {
                    addButton.addEventListener('click', () => {
                        const nextValue = addSelect.value;
                        if (!nextValue) return;
                        updateSemEdxManualAssociations(imagePath, [...selectedItems, nextValue]);
                        refreshFileList();
                    });
                } else {
                    addRow.classList.add('is-placeholder');
                    addSelect.disabled = true;
                    addButton.disabled = true;
                }
                addRow.appendChild(addSelect);
                addRow.appendChild(addButton);
                list.appendChild(addRow);
            }

            return list;
        }

        function renderSemEdxManualTree(node, depth = 0, pathPrefix = '', options = {}) {
            const { associations = null, mode = 'automatic', txtLookup = new Map() } = options;
            const list = document.createElement('ul');
            node.children.forEach((child) => {
                if (child.totalFiles < 1) {
                    return;
                }
                const item = document.createElement('li');
                item.classList.add('tree-node');

                const row = document.createElement('div');
                row.classList.add('tree-row');
                row.style.setProperty('--depth', depth);

                const nameCell = document.createElement('div');
                nameCell.classList.add('tree-name-cell');

                const toggle = document.createElement('button');
                toggle.type = 'button';
                toggle.classList.add('tree-toggle');
                toggle.textContent = '▸';
                toggle.setAttribute('aria-expanded', 'false');
                toggle.setAttribute('aria-label', `Expand ${child.name}`);

                const icon = createIcon('folder');
                const label = document.createElement('span');
                label.classList.add('tree-name');
                label.textContent = child.name;

                const itemCount = child.totalFiles;
                const meta = document.createElement('span');
                meta.classList.add('tree-meta');
                meta.textContent = `${itemCount} file${itemCount === 1 ? '' : 's'}`;

                nameCell.appendChild(toggle);
                nameCell.appendChild(icon);
                nameCell.appendChild(label);
                nameCell.appendChild(meta);

                const appendedCell = document.createElement('div');
                appendedCell.classList.add('sem-edx-appended-cell');

                row.appendChild(nameCell);
                row.appendChild(appendedCell);

                const folderPath = child.isRootGroup ? '' : `${pathPrefix}${child.name}/`;
                const isExpanded = semEdxExpandedNodes.has(folderPath);
                const childrenList = renderSemEdxManualTree(child, depth + 1, folderPath, {
                    associations,
                    mode,
                    txtLookup,
                });
                childrenList.classList.add('tree-children');
                childrenList.hidden = !isExpanded;
                toggle.setAttribute('aria-expanded', String(isExpanded));
                toggle.textContent = isExpanded ? '▾' : '▸';

                toggle.addEventListener('click', () => {
                    const expanded = toggle.getAttribute('aria-expanded') === 'true';
                    toggle.setAttribute('aria-expanded', String(!expanded));
                    toggle.textContent = expanded ? '▸' : '▾';
                    toggle.setAttribute('aria-label', `${expanded ? 'Expand' : 'Collapse'} ${child.name}`);
                    childrenList.hidden = expanded;
                    if (expanded) {
                        semEdxExpandedNodes.delete(folderPath);
                    } else {
                        semEdxExpandedNodes.add(folderPath);
                    }
                });

                item.appendChild(row);
                item.appendChild(childrenList);
                list.appendChild(item);
            });

            node.files
                .sort((a, b) => a.name.localeCompare(b.name))
                .forEach((file) => {
                    const item = document.createElement('li');
                    item.classList.add('tree-node');
                    const row = document.createElement('div');
                    row.classList.add('tree-row', 'sem-edx-file-row');
                    row.style.setProperty('--depth', depth);

                    const nameCell = document.createElement('div');
                    nameCell.classList.add('tree-name-cell');

                    const spacer = document.createElement('span');
                    spacer.classList.add('tree-spacer');

                    const icon = createIcon('file');
                    const label = document.createElement('span');
                    label.classList.add('tree-file-name');
                    label.textContent = file.name;

                    const appendedCell = document.createElement('div');
                    appendedCell.classList.add('sem-edx-appended-cell');

                    nameCell.appendChild(spacer);
                    nameCell.appendChild(icon);
                    nameCell.appendChild(label);

                    const directory = getSemEdxDirectory(file.rawPath);
                    const txtOptions = txtLookup.get(directory) || [];
                    const appendedList = renderSemEdxAppendedList(file.rawPath, {
                        associations,
                        mode,
                        txtOptions,
                    });
                    appendedCell.appendChild(appendedList);

                    row.appendChild(nameCell);
                    row.appendChild(appendedCell);
                    item.appendChild(row);
                    list.appendChild(item);
                });

            return list;
        }

        function renderSemEdxAssociations() {
            if (!fileTree) return;
            fileTree.innerHTML = '';
            fileTree.classList.add('sem-edx-associations');

            ensureSemEdxAutomaticAssociations();

            const toggleWrapper = document.createElement('div');
            toggleWrapper.classList.add('sem-edx-mode-toggle');
            const toggle = document.createElement('div');
            toggle.classList.add('user-setting-toggle');
            toggle.setAttribute('role', 'group');
            toggle.setAttribute('aria-label', 'SEM EDX association mode');

            const autoId = 'sem_edx_mode_auto';
            const manualId = 'sem_edx_mode_manual';

            const autoInput = document.createElement('input');
            autoInput.type = 'radio';
            autoInput.id = autoId;
            autoInput.name = 'sem_edx_mode';
            autoInput.value = 'automatic';
            autoInput.checked = semEdxAssociationMode === 'automatic';

            const autoLabel = document.createElement('label');
            autoLabel.setAttribute('for', autoId);
            autoLabel.textContent = 'Automatic';

            const manualInput = document.createElement('input');
            manualInput.type = 'radio';
            manualInput.id = manualId;
            manualInput.name = 'sem_edx_mode';
            manualInput.value = 'manual';
            manualInput.checked = semEdxAssociationMode === 'manual';

            const manualLabel = document.createElement('label');
            manualLabel.setAttribute('for', manualId);
            manualLabel.textContent = 'Manual';

            autoInput.addEventListener('change', () => {
                if (autoInput.checked) {
                    setSemEdxAssociationMode('automatic');
                }
            });
            manualInput.addEventListener('change', () => {
                if (manualInput.checked) {
                    setSemEdxAssociationMode('manual');
                }
            });

            toggle.appendChild(autoInput);
            toggle.appendChild(autoLabel);
            toggle.appendChild(manualInput);
            toggle.appendChild(manualLabel);
            toggleWrapper.appendChild(toggle);
            fileTree.appendChild(toggleWrapper);

            const manualPanel = document.createElement('div');
            manualPanel.classList.add('sem-edx-association-table');

            const header = document.createElement('div');
            header.classList.add('tree-header');
            header.innerHTML = `
                <span>IMAGE FILES</span>
                <span>APPENDED TXT</span>
            `;
            manualPanel.appendChild(header);

            const imageEntries = getSemEdxImageEntries(pendingFiles);
            if (!imageEntries.length) {
                const empty = document.createElement('div');
                empty.classList.add('sem-edx-empty');
                empty.textContent = 'No image files available.';
                manualPanel.appendChild(empty);
            } else {
                const tree = buildTree(imageEntries);
                primeSemEdxExpandedNodes(tree);
                const txtLookup = buildSemEdxTxtLookup(pendingFiles);
                const associations = semEdxAssociationMode === 'manual'
                    ? semEdxManualAssociations
                    : semEdxAssociationCache;
                if (semEdxAssociationMode === 'manual') {
                    ensureSemEdxManualAssociations(semEdxAssociationCache);
                }
                manualPanel.appendChild(renderSemEdxManualTree(tree, 0, '', {
                    associations,
                    mode: semEdxAssociationMode,
                    txtLookup,
                }));
            }

            fileTree.appendChild(manualPanel);
            updateSemEdxStatus();
        }

        function refreshFileList() {
            fileTree.innerHTML = '';
            fileTree.classList.remove('sem-edx-associations');
            fileInput.classList.toggle('has-files', pendingFiles.length > 0);
            if (isSemEdxSelected() && semEdxInstructionStep > 1) {
                renderSemEdxAssociations();
                return;
            }
            if (!pendingFiles.length) {
                return;
            }
            const header = document.createElement('div');
            header.classList.add('tree-header');
            header.innerHTML = `
                <span>Name</span>
                <span style="text-align: right;">Size</span>
                <span>Last modified</span>
                <span></span>
            `;
            fileTree.appendChild(header);
            const tree = buildTree(pendingFiles);
            fileTree.appendChild(renderTree(tree));
        }

        function focusFallbackElement(options = {}) {
            const { allowSelectInputs = true } = options;
            const candidates = [
                uploadBtn,
                nextStepBtn,
                previousStepBtn,
                fileBtn,
                folderBtn,
                cancelUploadBtn,
                cancelImportBtn
            ];
            if (allowSelectInputs) {
                candidates.push(projectSelectInput, specialUploadInput);
            }
            const target = candidates.find((element) => (
                element &&
                typeof element.focus === 'function' &&
                !element.disabled &&
                element.offsetParent !== null
            ));
            if (target) {
                target.focus();
                return;
            }
            if (document.body && typeof document.body.focus === 'function') {
                document.body.focus();
            }
        }

        function showDuplicatePopup(message) {
            duplicateMessage.textContent = message;
            duplicateOverlay.style.display = 'block';
            duplicatePopup.style.display = 'block';
            duplicatePopup.setAttribute('aria-hidden', 'false');
            duplicateOkBtn.focus();
        }

        function hideDuplicatePopup() {
            if (duplicatePopup.contains(document.activeElement)) {
                focusFallbackElement();
            }
            duplicateOverlay.style.display = 'none';
            duplicatePopup.style.display = 'none';
            duplicatePopup.setAttribute('aria-hidden', 'true');
        }

        function showCompatibilityPopup(message) {
            compatibilityMessage.textContent = message;
            compatibilityOverlay.style.display = 'block';
            compatibilityPopup.style.display = 'block';
            compatibilityPopup.setAttribute('aria-hidden', 'false');
            window.setTimeout(() => {
                compatibilityNoBtn.focus();
            }, 0);
            return new Promise((resolve) => {
                compatibilityPopupResolver = resolve;
            });
        }

        function resolveCompatibilityPopup(decision) {
            if (compatibilityPopupResolver) {
                compatibilityPopupResolver(decision);
                compatibilityPopupResolver = null;
            }
            if (compatibilityPopup.contains(document.activeElement)) {
                suppressProjectDropdownOpenOnFocusOnce = true;
                suppressSpecialUploadDropdownOpenOnFocusOnce = true;
                focusFallbackElement({ allowSelectInputs: false });
            }
            compatibilityOverlay.style.display = 'none';
            compatibilityPopup.style.display = 'none';
            compatibilityPopup.setAttribute('aria-hidden', 'true');
        }

        function showSemEdxConfirmPopup(message) {
            semEdxConfirmMessage.textContent = message;
            semEdxConfirmOverlay.style.display = 'block';
            semEdxConfirmPopup.style.display = 'block';
            semEdxConfirmPopup.setAttribute('aria-hidden', 'false');
            semEdxConfirmYesBtn.focus();
            return new Promise((resolve) => {
                semEdxConfirmPopupResolver = resolve;
            });
        }

        function resolveSemEdxConfirmPopup(decision) {
            if (semEdxConfirmPopupResolver) {
                semEdxConfirmPopupResolver(decision);
                semEdxConfirmPopupResolver = null;
            }
            if (semEdxConfirmPopup.contains(document.activeElement)) {
                suppressProjectDropdownOpenOnFocusOnce = true;
                suppressSpecialUploadDropdownOpenOnFocusOnce = true;
                focusFallbackElement({ allowSelectInputs: false });
            }
            semEdxConfirmOverlay.style.display = 'none';
            semEdxConfirmPopup.style.display = 'none';
            semEdxConfirmPopup.setAttribute('aria-hidden', 'true');
        }

        function delay(ms) {
            return new Promise((resolve) => {
                window.setTimeout(resolve, ms);
            });
        }

        function getRootInfo(entry) {
            const rawPath = getEntryPath(entry);
            const parts = rawPath.split('/').filter(Boolean);
            const rootName = parts[0] || rawPath;
            return { rootName, isRootFile: parts.length <= 1 };
        }

        function findDuplicateRootNames(entries) {
            const existingRootNames = new Set();

            pendingFiles.forEach((entry) => {
                const info = getRootInfo(entry);
                if (info.rootName) {
                    existingRootNames.add(info.rootName);
                }
            });

            const incomingRootFiles = new Set();
            const incomingRootFolders = new Set();
            const duplicates = new Set();

            entries.forEach((entry) => {
                const info = getRootInfo(entry);
                if (!info.rootName) {
                    return;
                }
                if (info.isRootFile) {
                    if (
                        existingRootNames.has(info.rootName)
                        || incomingRootFiles.has(info.rootName)
                        || incomingRootFolders.has(info.rootName)
                    ) {
                        duplicates.add(info.rootName);
                    }
                    incomingRootFiles.add(info.rootName);
                    return;
                }
                if (existingRootNames.has(info.rootName) || incomingRootFiles.has(info.rootName)) {
                    duplicates.add(info.rootName);
                }
                incomingRootFolders.add(info.rootName);
            });

            return duplicates;
        }

        function normalizeFileList(files) {
            return Array.from(files).map((file) => ({
                file,
                relativePath: file.webkitRelativePath || file.name,
            }));
        }

        async function collectDirectoryHandleFiles(handle, prefix = '') {
            const entries = [];
            for await (const entry of handle.values()) {
                if (entry.kind === 'file') {
                    const file = await entry.getFile();
                    entries.push({ file, relativePath: `${prefix}${entry.name}` });
                } else if (entry.kind === 'directory') {
                    const nested = await collectDirectoryHandleFiles(entry, `${prefix}${entry.name}/`);
                    entries.push(...nested);
                }
            }
            return entries;
        }

        async function openFilePicker() {
            if (typeof window.showOpenFilePicker !== 'function') {
                return;
            }
            const collected = [];
            try {
                const fileHandles = await window.showOpenFilePicker({ multiple: true });
                for (const handle of fileHandles) {
                    const file = await handle.getFile();
                    collected.push({ file, relativePath: file.name });
                }
            } catch (error) {
                if (error?.name !== 'AbortError') {
                    throw error;
                }
            }
            if (collected.length) {
                handleFiles(collected);
            }
        }

        async function openFolderPicker() {
            if (typeof window.showDirectoryPicker !== 'function') {
                return;
            }
            const collected = [];
            try {
                const dirHandle = await window.showDirectoryPicker();
                const dirEntries = await collectDirectoryHandleFiles(dirHandle, `${dirHandle.name}/`);
                collected.push(...dirEntries);
            } catch (error) {
                if (error?.name !== 'AbortError') {
                    throw error;
                }
            }
            if (collected.length) {
                handleFiles(collected);
            }
        }

        function handleFiles(entries) {
            const duplicates = findDuplicateRootNames(entries);
            if (duplicates.size) {
                showDuplicatePopup(
                    'Some of the selected items are already in the upload list.\n' +
                    'Remove existing entries or rename them before uploading.'
                );
                return;
            }
            pendingFiles = pendingFiles.concat(entries);
            invalidateSemEdxAssociations();
            refreshFileList();
            if (updateSemEdxStatus()) {
                return;
            }
            if (hasActiveImport()) {
                setStatus('Ready to upload. A previous import job is currently running.', 'success');
            } else {
                setStatus('');
            }
        }

        function readAllDirectoryEntries(reader) {
            return new Promise((resolve, reject) => {
                const entries = [];
                const readChunk = () => {
                    reader.readEntries((batch) => {
                        if (!batch.length) {
                            resolve(entries);
                            return;
                        }
                        entries.push(...batch);
                        readChunk();
                    }, reject);
                };
                readChunk();
            });
        }

        async function traverseEntry(entry, pathPrefix = '') {
            if (!entry) {
                return [];
            }
            if (entry.isFile) {
                return new Promise((resolve, reject) => {
                    entry.file((file) => {
                        resolve([{ file, relativePath: `${pathPrefix}${file.name}` }]);
                    }, reject);
                });
            }
            if (entry.isDirectory) {
                const reader = entry.createReader();
                const children = await readAllDirectoryEntries(reader);
                const results = [];
                for (const child of children) {
                    const childResults = await traverseEntry(child, `${pathPrefix}${entry.name}/`);
                    results.push(...childResults);
                }
                return results;
            }
            return [];
        }

        async function getFilesFromDrop(event) {
            const items = Array.from(event.dataTransfer?.items || []);
            const entries = [];
            for (const item of items) {
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                    if (entry) {
                        entries.push(entry);
                    } else if (item.getAsFile()) {
                        entries.push({ isFile: true, file: (callback) => callback(item.getAsFile()) });
                    }
                }
            }
            if (!entries.length && event.dataTransfer?.files?.length) {
                return normalizeFileList(event.dataTransfer.files);
            }
            const collected = [];
            for (const entry of entries) {
                const results = await traverseEntry(entry);
                collected.push(...results);
            }
            return collected;
        }

        window.addEventListener('dragover', (event) => {
            if (!event.dataTransfer) {
                return;
            }
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
        });

        window.addEventListener('drop', (event) => {
            if (!event.dataTransfer) {
                return;
            }
            event.preventDefault();
        });

        uploadCard.addEventListener('dragover', (event) => {
            event.stopPropagation();
            if (isUploading || isSemEdxAddLocked()) {
                return;
            }
            event.preventDefault();
            uploadCard.classList.add('dragover');
        });

        uploadCard.addEventListener('dragleave', () => {
            uploadCard.classList.remove('dragover');
        });

        uploadCard.addEventListener('drop', async (event) => {
            event.preventDefault();
            if (isUploading || isSemEdxAddLocked()) {
                return;
            }
            uploadCard.classList.remove('dragover');
            if (!uploadEnabled) {
                setStatus('Upload folder is not writable. Please contact the server administrator.', 'error');
                return;
            }
            const files = await getFilesFromDrop(event);
            if (!files.length) {
                setStatus('No files detected in the dropped folder.', 'error');
                return;
            }
            handleFiles(files);
        });

        fileInput.addEventListener('change', () => {
            if (!uploadEnabled) {
                setStatus('Upload folder is not writable. Please contact the server administrator.', 'error');
                return;
            }
            if (isUploading || isSemEdxAddLocked()) {
                return;
            }
            if (fileInput.files?.length) {
                handleFiles(normalizeFileList(fileInput.files));
            }
        });
        if (fileBtn) {
            fileBtn.addEventListener('click', async () => {
                if (!uploadEnabled) {
                    setStatus('Upload folder is not writable. Please contact the server administrator.', 'error');
                    return;
                }
                if (isUploading || isSemEdxAddLocked()) {
                    return;
                }
                if (typeof window.showOpenFilePicker === 'function') {
                    try {
                        await openFilePicker();
                    } catch (error) {
                        setStatus(`Upload selection failed: ${error.message || error}`, 'error');
                    }
                    return;
                }
                fileInput.value = '';
                fileInput.click();
            });
        }
        if (folderBtn) {
            folderBtn.addEventListener('click', async () => {
                if (!uploadEnabled) {
                    setStatus('Upload folder is not writable. Please contact the server administrator.', 'error');
                    return;
                }
                if (isUploading || isSemEdxAddLocked()) {
                    return;
                }
                if (canUseDirectoryPicker) {
                    try {
                        await openFolderPicker();
                    } catch (error) {
                        setStatus(`Folder selection failed: ${error.message || error}`, 'error');
                    }
                    return;
                }
                if (canUseFolderInput) {
                    folderInput.value = '';
                    folderInput.click();
                    return;
                }
                setStatus('Folder selection is unavailable in this browser. Drag & drop a folder instead.', 'error');
            });
        }
        folderInput.addEventListener('change', () => {
            if (!uploadEnabled) {
                setStatus('Upload folder is not writable. Please contact the server administrator.', 'error');
                return;
            }
            if (isUploading || isSemEdxAddLocked()) {
                return;
            }
            if (folderInput.files?.length) {
                handleFiles(normalizeFileList(folderInput.files));
            }
        });

        duplicateOverlay.addEventListener('click', hideDuplicatePopup);
        duplicateOkBtn.addEventListener('click', hideDuplicatePopup);
        compatibilityOverlay.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            resolveCompatibilityPopup(false);
        });
        compatibilityYesBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            resolveCompatibilityPopup(true);
        });
        compatibilityNoBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            resolveCompatibilityPopup(false);
        });
        semEdxConfirmOverlay.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            resolveSemEdxConfirmPopup(false);
        });
        semEdxConfirmYesBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            resolveSemEdxConfirmPopup(true);
        });
        semEdxConfirmNoBtn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            resolveSemEdxConfirmPopup(false);
        });

        async function parseJsonResponse(response) {
            let text = '';
            try {
                text = await response.text();
            } catch (error) {
                throw new Error(`Failed to read response: ${error.message || error}`);
            }
            
            const contentType = response.headers.get('content-type') || '';
            if (!text) {
                return {};
            }
            if (contentType.includes('text/html')) {
                const snippet = text.trim().slice(0, 160);
                const redirected = response.redirected ? ' Request was redirected.' : '';
                const details = snippet ? ` Response: ${snippet}` : '';
                throw new Error(`Server returned HTML instead of JSON.${redirected}${details}`);
            }
            try {
                return JSON.parse(text);
            } catch (error) {
                const snippet = text.trim().slice(0, 160);
                const details = snippet ? ` Response: ${snippet}` : '';
                throw new Error(`Server returned invalid JSON.${details} Parse error: ${error.message}`);
            }
        }

        async function fetchJobStatus(job) {
            const response = await fetch(job.status_url, { credentials: 'same-origin' });
            const data = await parseJsonResponse(response);
            if (!response.ok || !data.ok) {
                throw new Error(data.error || `Status check failed with status ${response.status}.`);
            }
            return data;
        }

        async function waitForCompatibility(job) {
            if (!job?.status_url) {
                return { confirmation_required: false, compatibility_status: 'compatible', status: 'ready' };
            }
            const maxAttempts = 300;
            const maxTimeMs = 5 * 60 * 1000; // 5 minutes
            const startTime = Date.now();
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                // Check absolute timeout
                if (Date.now() - startTime > maxTimeMs) {
                    throw new Error('Compatibility check timeout - operation took too long. Please try again.');
                }
                
                const data = await fetchJobStatus(job);
                
                if (data.compatibility_checked !== undefined && data.compatibility_total !== undefined) {
                    const total = data.compatibility_total || 0;
                    if (total > 0) {
                        if (uploadOverlay) {
                            uploadOverlay.textContent = 'UPLOADED. CHECKING COMPATIBILITY...';
                        }
                    }
                }
                
                const compatibilityStatus = data.compatibility_status || data.status;
                if (compatibilityStatus === 'checking' || compatibilityStatus === 'pending') {
                    await delay(800);
                    attempts++;
                    continue;
                }
                return data;
            }
            throw new Error('Compatibility check timeout - maximum attempts exceeded.');
        }

        async function confirmCompatibility(job) {
            const response = await fetch(job.confirm_url, {
                method: 'POST',
                headers: setRequestHeaders({ 'Content-Type': 'application/json' }),
                credentials: 'same-origin',
            });
            const data = await parseJsonResponse(response);
            if (!response.ok || !data.ok) {
                throw new Error(data.error || `Compatibility confirmation failed with status ${response.status}.`);
            }
            return data;
        }

        async function pruneUploadJob(job, keepPaths) {
            if (!job?.prune_url) {
                return;
            }
            const response = await fetch(job.prune_url, {
                method: 'POST',
                headers: setRequestHeaders({ 'Content-Type': 'application/json' }),
                body: JSON.stringify({ keep_paths: keepPaths }),
                credentials: 'same-origin',
            });
            const data = await parseJsonResponse(response);
            if (!response.ok || !data.ok) {
                throw new Error(data.error || `Failed to update removed files with status ${response.status}.`);
            }
            return data;
        }

        function getEntryPath(entry) {
            const rawPath = entry?.relativePath || entry?.file?.name || '';
            return normalizeCompatibilityPath(rawPath);
        }

        function normalizeCompatibilityPath(rawPath) {
            if (!rawPath) {
                return '';
            }
            return rawPath
                .replace(/\\/g, '/')
                .replace(/^\.\/+/, '')
                .replace(/^\/+/, '')
                .replace(/\/+/g, '/');
        }

        function applyCompatibilityFlags(entries, incompatibleFiles) {
            const incompatibleSet = new Set(
                (incompatibleFiles || []).map(normalizeCompatibilityPath)
            );
            let changed = false;
            entries.forEach((entry) => {
                const normalized = getEntryPath(entry);
                const isIncompatible = incompatibleSet.has(normalized);
                if (entry.isIncompatible !== isIncompatible) {
                    entry.isIncompatible = isIncompatible;
                    changed = true;
                }
            });
            return changed;
        }

        function filterCompatibilityIncompatibleFiles(incompatibleFiles) {
            const files = (incompatibleFiles || []).map(normalizeCompatibilityPath).filter(Boolean);
            if (!isSemEdxSelected()) {
                return files;
            }
            return files.filter((path) => !path.toLowerCase().endsWith('.txt'));
        }

        async function ensureCompatibilityBeforeImport(job, uploadedFiles) {
            if (!isCompatibilityEnabled()) {
                return { proceed: true, status: { compatibility_status: 'skipped', status: 'ready' } };
            }
            const statusData = await waitForCompatibility(job);
            const incompatibleFiles = filterCompatibilityIncompatibleFiles(statusData.incompatible_files);
            applyCompatibilityFlags(uploadedFiles, incompatibleFiles);
            if (statusData.confirmation_required && incompatibleFiles.length) {
                const isSemEdx = specialUploadSelect?.value === 'sem_edx_spectra';
                const message = isSemEdx
                    ? 'Incompatible file(s) found. Do you still want to continue with the upload?\nSUGGESTED: No'
                    : 'Incompatible file(s) found. Do you still want to continue with the upload?\nSUGGESTED: No';
                const proceed = await showCompatibilityPopup(message);
                if (!proceed) {
                    skipSpecialUploadReset = true;
                    window.pendingImportJob = job;
                    window.pendingImportFiles = uploadedFiles;
                    pendingFiles = [...uploadedFiles];
                    applyCompatibilityFlags(pendingFiles, incompatibleFiles);
                    if (isSemEdxSelected()) {
                        setSemEdxInstructionsStep(1);
                    } else {
                        refreshFileList();
                    }
                    updateUploadButtonLabel();
                    setStatus(
                        'Upload complete. Import halted because incompatible files were detected. Remove all incompatible files and click "Continue Import".',
                        'error'
                    );
                    return { proceed: false, status: statusData, uploadedFiles };
                }
                await confirmCompatibility(job);
            } else if (statusData.confirmation_required) {
                await confirmCompatibility(job);
            }
            return { proceed: true, status: statusData };
        }

        async function startUploadJob(entries = pendingFiles) {
            const totalBytes = entries.reduce((acc, entry) => acc + normalizeByteSize(entry.file?.size), 0);
            const shouldSkipSemEdx = (entry) => isSemEdxSelected() && isSemEdxTxtEntry(entry);
            const metadata = entries.map((entry) => ({
                name: entry.file.name,
                relative_path: getEntryPath(entry),
                size: normalizeByteSize(entry.file?.size),
                compatibility_skip: shouldSkipSemEdx(entry),
                import_skip: shouldSkipSemEdx(entry),
            }));
            const projectId = projectSelect?.value || '';
            const projectName = projectSelectInput?.dataset.selectedName || projectSelectInput?.value || '';
            const specialUploadValue = specialUploadSelect?.value || '';

            let semEdxAssociations = null;
            if (isSemEdxSelected()) {
                semEdxAssociations = buildSemEdxAssociationPayload(entries);
            }
            let semEdxSettings = null;
            if (isSemEdxSelected()) {
                semEdxSettings = getSemEdxSettingsPayload();
            }

            const response = await fetch(startUrl, {
                method: 'POST',
                headers: setRequestHeaders({ 'Content-Type': 'application/json' }),
                body: JSON.stringify({
                    files: metadata,
                    project_id: projectId,
                    project_name: projectName,
                    compatibility_enabled: isCompatibilityEnabled(),
                    special_upload: specialUploadValue,
                    sem_edx_associations: semEdxAssociations,
                    sem_edx_settings: semEdxSettings,
                    batch_size: currentUploadBatchFiles,
                }),
                credentials: 'same-origin',
            });
            
            const data = await parseJsonResponse(response);
            if (!response.ok || !data.ok) {
                throw new Error(data.error || `Upload start failed with status ${response.status}.`);
            }
            return { ...data, totalBytes };
        }

        function createUploadBatches(entries = pendingFiles) {
            const maxBatchBytes = 50 * 1024 * 1024;
            const maxBatchFiles = Math.max(1, currentUploadBatchFiles);
            const batches = [];
            let current = [];
            let currentBytes = 0;

            entries.forEach((entry) => {
                const fileSize = normalizeByteSize(entry.file?.size);

                if (fileSize < 0 || fileSize > Number.MAX_SAFE_INTEGER) {
                    console.error(`Invalid file size: ${fileSize} for ${getEntryPath(entry)}`);
                    return;
                }

                const needsSplit = current.length >= maxBatchFiles ||
                    (currentBytes + fileSize > maxBatchBytes && current.length > 0);
                if (needsSplit) {
                    batches.push(current);
                    current = [];
                    currentBytes = 0;
                }
                current.push(entry);
                currentBytes += fileSize;
            });

            if (current.length > 0) {
                batches.push(current);
            }
            return batches;
        }

        function uploadBatch(uploadUrl, batch) {
            return new Promise((resolve, reject) => {
                if (cancelUploadRequested) {
                    reject(new Error('Upload canceled.'));
                    return;
                }
                const formData = new FormData();
                const batchTotalBytes = batch.reduce((acc, entry) => acc + normalizeByteSize(entry.file?.size), 0);
                
                // Validate batch before processing
                if (batch.length === 0) {
                    reject(new Error('Empty batch provided'));
                    return;
                }
                
                batch.forEach((entry) => {
                    const relativePath = getEntryPath(entry);
                    if (!relativePath) {
                        reject(new Error('Invalid file entry: missing path'));
                        return;
                    }
                    if (!entry.file) {
                        reject(new Error('Invalid file entry: missing file object'));
                        return;
                    }
                    formData.append('files', entry.file, relativePath);
                    formData.append('relative_paths', relativePath);
                });

                const xhr = new XMLHttpRequest();
                xhr.open('POST', uploadUrl);
                xhr.withCredentials = true;
                xhr.timeout = uploadRequestTimeoutMs;
                setRequestHeaders({}, xhr);
                registerActiveRequest(xhr);
                setUploadProgressEntry(xhr, 0, batchTotalBytes);
                xhr.upload.onprogress = (event) => {
                    const total = event.lengthComputable ? event.total : batchTotalBytes;
                    const loaded = event.lengthComputable ? event.loaded : Math.min(event.loaded, total);
                    setUploadProgressEntry(xhr, loaded, total);
                };
                xhr.upload.onloadend = () => {
                    setUploadProgressEntry(xhr, batchTotalBytes, batchTotalBytes);
                };
                xhr.onload = () => {
                    if (cancelUploadRequested) {
                        reject(new Error('Upload canceled.'));
                        return;
                    }
                    const responseText = xhr.responseText || '';
                    const contentType = xhr.getResponseHeader('content-type') || '';
                    if (contentType.includes('text/html')) {
                        const snippet = responseText.trim().slice(0, 160);
                        const redirected = xhr.responseURL && xhr.responseURL !== uploadUrl
                            ? ' Request was redirected.'
                            : '';
                        const details = snippet ? ` Response: ${snippet}` : '';
                        reject(new Error(`Server returned HTML instead of JSON.${redirected}${details}`));
                        return;
                    }
                    let responseData = {};
                    if (responseText) {
                        try {
                            responseData = JSON.parse(responseText);
                        } catch (error) {
                            const snippet = responseText.trim().slice(0, 160);
                            const details = snippet ? ` Response: ${snippet}` : '';
                            reject(new Error(`Server returned invalid JSON.${details}`));
                            return;
                        }
                    }
                    if (xhr.status >= 400 || !responseData.ok) {
                        reject(new Error(responseData.error || 'Upload failed.'));
                        return;
                    }
                    setUploadProgressEntry(xhr, batchTotalBytes, batchTotalBytes);
                    resolve(responseData);
                };
                xhr.onabort = () => reject(new Error('Upload canceled.'));
                xhr.onerror = () => reject(new Error('Upload failed.'));
                xhr.ontimeout = () => reject(new Error('Upload timed out waiting for a server response.'));
                xhr.send(formData);
            });
        }

        async function uploadFiles(uploadUrl, entries = pendingFiles) {
            const batches = createUploadBatches(entries);
            const concurrency = Math.min(uploadConcurrency, batches.length);

            const tasks = batches.map((batch, index) => async () => {
                await uploadBatch(uploadUrl, batch);
            });

            let taskIndex = 0;
            const workers = new Array(concurrency).fill(null).map(async () => {
                while (taskIndex < tasks.length) {
                    if (cancelUploadRequested) {
                        return;
                    }
                    const currentIndex = taskIndex;
                    taskIndex += 1;
                    await tasks[currentIndex]();
                }
            });
            await Promise.all(workers);
        }

        function escapeHtml(value) {
            if (value == null) {
                return '';
            }
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function formatImportLogEntry(entry) {
            const rawEntry = String(entry ?? '');
            const successMatch = rawEntry.match(/^Import success(?:\s*:)?\s*(.*)$/);
            if (successMatch) {
                const detail = successMatch[1] ? escapeHtml(successMatch[1].trim()) : '';
                const rest = detail ? `: ${detail}` : ':';
                return `<span class="import-log-label import-log-label--success">Import success</span>` +
                    `<span class="import-log-rest">${rest}</span>`;
            }
            const failureMatch = rawEntry.match(/^Import failure(?:\s*:)?\s*(.*)$/);
            if (failureMatch) {
                const detail = failureMatch[1] ? escapeHtml(failureMatch[1].trim()) : '';
                const rest = detail ? `: ${detail}` : ':';
                return `<span class="import-log-label import-log-label--failure">Import failure</span>` +
                    `<span class="import-log-rest">${rest}</span>`;
            }
            const attachSuccessMatch = rawEntry.match(/^Txt attachment success(?:\s*:)?\s*(.*)$/);
            if (attachSuccessMatch) {
                const detail = attachSuccessMatch[1] ? escapeHtml(attachSuccessMatch[1].trim()) : '';
                const rest = detail ? `: ${detail}` : ':';
                return `<span class="import-log-label import-log-label--success">Txt attachment success</span>` +
                    `<span class="import-log-rest">${rest}</span>`;
            }
            const attachFailureMatch = rawEntry.match(/^Txt attachment failure(?:\s*:)?\s*(.*)$/);
            if (attachFailureMatch) {
                const detail = attachFailureMatch[1] ? escapeHtml(attachFailureMatch[1].trim()) : '';
                const rest = detail ? `: ${detail}` : ':';
                return `<span class="import-log-label import-log-label--failure">Txt attachment failure</span>` +
                    `<span class="import-log-rest">${rest}</span>`;
            }
            const skipMatch = rawEntry.match(/^Auto-skipped\s*\(([^)]*)\)(?:\s*:)?\s*(.*)$/);
            if (skipMatch) {
                const reason = skipMatch[1] ? escapeHtml(skipMatch[1].trim()) : '';
                const detail = skipMatch[2] ? escapeHtml(skipMatch[2].trim()) : '';
                const rest = detail ? `: ${detail}` : '';
                return `<span class="import-log-label import-log-label--skipped">Auto-skipped</span>` +
                    `<span class="import-log-rest"> (${reason})${rest}</span>`;
            }
            return escapeHtml(rawEntry);
        }

        function updateImportLog(entries) {
            if (!entries || !entries.length) {
                return;
            }
            const maxLines = 1000;
            const trimmed = entries.length > maxLines ? entries.slice(-maxLines) : entries;
            if (entries.length > maxLines) {
                importLogEntries.splice(0, importLogEntries.length - maxLines);
            }
            const formatted = trimmed.map((entry) => formatImportLogEntry(entry));
            progressLog.innerHTML = formatted.join('\n');
        }

        function persistImportState() {
            if (!storage) {
                return;
            }
            try {
                const jobs = Array.from(importJobs.values()).map((job, index) => ({
                    job_id: job.job_id,
                    status_url: job.status_url,
                    confirm_url: job.confirm_url || null,
                    compatibility_enabled: job.compatibility_enabled !== false,
                    total_bytes: job.total_bytes,
                    status: job.status,
                    created: job.created || index,
                }));
                storage.setItem(importJobsStorageKey, JSON.stringify(jobs));
                storage.setItem(
                    importLogsStorageKey,
                    JSON.stringify({
                        entries: importLogEntries,
                        state: Array.from(importLogState.entries()),
                    })
                );
            } catch (error) {
                // Ignore storage failures.
            }
        }

        function restoreImportState() {
            if (!storage) {
                return;
            }
            try {
                let restoredLogs = false;
                const rawJobs = storage.getItem(importJobsStorageKey);
                if (rawJobs) {
                    const savedJobs = JSON.parse(rawJobs);
                    savedJobs
                        .sort((a, b) => (a.created || 0) - (b.created || 0))
                        .forEach((job) => {
                            if (!job || !job.job_id || !job.status_url) {
                                return;
                            }
                            importJobs.set(job.job_id, {
                                job_id: job.job_id,
                                status_url: job.status_url,
                                confirm_url: job.confirm_url || null,
                                status: job.status || 'pending',
                                compatibility_enabled: job.compatibility_enabled !== false,
                                imported_bytes: 0,
                                total_bytes: job.total_bytes || 0,
                                messages: [],
                                errors: [],
                                created: job.created || Date.now(),
                            });
                        });
                }
                const rawLogs = storage.getItem(importLogsStorageKey);
                if (rawLogs) {
                    const savedLogs = JSON.parse(rawLogs);
                    if (Array.isArray(savedLogs.entries)) {
                        importLogEntries.splice(0, importLogEntries.length, ...savedLogs.entries);
                        updateImportLog(importLogEntries);
                        restoredLogs = true;
                    }
                    if (Array.isArray(savedLogs.state)) {
                        importLogState.clear();
                        savedLogs.state.forEach(([jobId, count]) => {
                            if (jobId) {
                                importLogState.set(jobId, count);
                            }
                        });
                    }
                }
                if (!hasActiveImport() && (importJobs.size || restoredLogs)) {
                    clearImportState();
                    setStatus('');
                }
            } catch (error) {
                // Ignore storage failures.
            }
        }

        function appendImportMessages(jobId, messages) {
            if (!messages || !messages.length) {
                return;
            }
            const previousCount = importLogState.get(jobId) || 0;
            if (messages.length < previousCount) {
                importLogState.set(jobId, messages.length);
                importLogEntries.push(...messages);
                updateImportLog(importLogEntries);
                return;
            }
            const newMessages = messages.slice(previousCount);
            if (!newMessages.length) {
                return;
            }
            importLogEntries.push(...newMessages);
            importLogState.set(jobId, messages.length);
            updateImportLog(importLogEntries);
        }

        function updateImportLogFromJobs(jobs) {
            jobs.forEach((job) => {
                const combined = [...(job.messages || [])];
                if (job.errors && job.errors.length) {
                    job.errors.forEach((err) => {
                        const prefixed = '[ERROR] ' + err;
                        if (!combined.includes(prefixed) && !combined.includes(err)) {
                            combined.push(prefixed);
                        }
                    });
                }
                appendImportMessages(job.job_id, combined);
            });
        }

        function updateProgressFromJobs() {
            if (!importJobs.size) {
                progressSection.style.display = 'none';
                updateUploadButtonLabel();
                updateCancelButtons();
                return;
            }
            progressSection.style.display = 'block';
            setProgressStage('Stage 2 of 2: Importing into OMERO');
            const jobs = Array.from(importJobs.values());
            const totalBytes = jobs.reduce((acc, job) => acc + (job.total_bytes || 0), 0);
            const importedBytes = jobs.reduce((acc, job) => acc + (job.imported_bytes || 0), 0);
            const hasErrors = jobs.some((job) => job.status === 'error');
            const percent = totalBytes ? Math.min(100, Math.round((importedBytes / totalBytes) * 100)) : 0;
            const anyAwaiting = jobs.some((job) => job.status === 'awaiting_confirmation');
            let progressLabel;
            if (anyAwaiting) {
                progressLabel = 'Preparing import...';
            } else if (totalBytes) {
                progressLabel = `Importing ${formatBytes(importedBytes)} of ${formatBytes(totalBytes)}...`;
            } else {
                progressLabel = 'Importing...';
            }
            updateProgress(percent, progressLabel);
            updateImportLogFromJobs(jobs);
            if (!hasActiveImport() && totalBytes) {
                if (hasErrors) {
                    const allErrors = jobs.flatMap((job) => job.errors || []);
                    updateProgress(100, 'Import completed with errors.');
                    setStatus(
                        'Import completed with errors: ' + (allErrors[0] || 'Check the log below for details.'),
                        'error'
                    );
                } else {
                    updateProgress(100, 'Import complete.');
                    setStatus('Import complete. Check the log below.', 'success');
                }
            }
            updateUploadButtonLabel();
            persistImportState();
            updateCancelButtons();
        }

        async function pollImportJobs() {
            const jobs = Array.from(importJobs.values());
            if (!jobs.length) {
                importPollTimer = null;
                updateProgressFromJobs();
                return;
            }
            try {
                await Promise.all(
                    jobs.map(async (job) => {
                        try {
                            const response = await fetch(job.status_url, {
                                method: 'POST',
                                headers: setRequestHeaders({}),
                                credentials: 'same-origin',
                            });
                            const data = await parseJsonResponse(response);
                            if (!response.ok || !data.ok) {
                                return;
                            }

                            // If the server reports awaiting_confirmation but we
                            // already passed the compatibility step, auto-confirm
                            // so the import can proceed.
                            if (data.status === 'awaiting_confirmation' && job.confirm_url) {
                                try {
                                    await fetch(job.confirm_url, {
                                        method: 'POST',
                                        headers: setRequestHeaders({ 'Content-Type': 'application/json' }),
                                        credentials: 'same-origin',
                                    });
                                } catch (_) { /* best-effort */ }
                            }

                            importJobs.set(job.job_id, {
                                ...job,
                                status: data.status || job.status,
                                compatibility_enabled: data.compatibility_enabled !== false,
                                uploaded_bytes: data.uploaded_bytes,
                                imported_bytes: data.imported_bytes,
                                total_bytes: data.total_bytes,
                                messages: data.messages || job.messages,
                                errors: data.errors || job.errors,
                            });
                        } catch (err) {
                            console.warn('Import poll error for job', job.job_id, err);
                        }
                    })
                );
            } catch (err) {
                console.warn('Import poll round failed:', err);
            }
            updateProgressFromJobs();
            if (hasActiveImport()) {
                importPollTimer = window.setTimeout(pollImportJobs, 4000);
            } else {
                importPollTimer = null;
            }
        }

        function ensureImportPolling() {
            if (!importPollTimer) {
                pollImportJobs();
            }
        }

        function registerImportJob(job) {
            importJobs.set(job.job_id, {
                job_id: job.job_id,
                status_url: job.status_url,
                confirm_url: job.confirm_url || null,
                status: 'ready',
                compatibility_enabled: job.compatibility_enabled !== false,
                imported_bytes: 0,
                total_bytes: job.totalBytes,
                messages: [],
                errors: [],
                created: Date.now(),
            });
            updateProgressFromJobs();
            ensureImportPolling();
        }

        function updateCancelButtons() {
            const showUploadCancel = isUploading;
            const showImportCancel = hasActiveImport();
            cancelUploadBtn.classList.toggle('action-hidden', !showUploadCancel);
            cancelUploadBtn.disabled = !showUploadCancel;
            cancelImportBtn.classList.toggle('action-hidden', !showImportCancel);
            cancelImportBtn.disabled = !showImportCancel;
        }

        function clearImportState() {
            importJobs.clear();
            importLogEntries.splice(0, importLogEntries.length);
            importLogState.clear();
            progressLog.textContent = '';
            setProgressStage('Stage: Waiting to start…');
            updateProgress(0, 'Waiting to start…');
            if (importPollTimer) {
                window.clearTimeout(importPollTimer);
                importPollTimer = null;
            }
            if (storage) {
                try {
                    storage.removeItem(importJobsStorageKey);
                    storage.removeItem(importLogsStorageKey);
                } catch (error) {
                    // Ignore storage failures.
                }
            }
            updateProgressFromJobs();
        }

        cancelImportBtn.addEventListener('click', () => {
            if (!hasActiveImport()) {
                return;
            }
            clearImportState();
            setStatus('Import canceled. You can start a new upload when ready.', 'success');
        });

        uploadBtn.addEventListener('click', async () => {
            if (isUploading) {
                return;
            }
            if (!pendingFiles.length) {
                setStatus('Please choose folders or files first.', 'error');
                return;
            }
            if (!uploadEnabled) {
                setStatus('Upload folder is not writable. Please contact the server administrator.', 'error');
                return;
            }
            if (!hasActiveImport()) {
                clearImportState();
                setStatus('');
            }

            if (window.pendingImportJob) {
                const job = window.pendingImportJob;
                const originalFiles = window.pendingImportFiles || [];
                const originalPaths = new Set(originalFiles.map((entry) => getEntryPath(entry)));
                const existingEntries = pendingFiles.filter((entry) => originalPaths.has(getEntryPath(entry)));
                const newEntries = pendingFiles.filter((entry) => !originalPaths.has(getEntryPath(entry)));
                let shouldContinue = true;
                setUploadingState(true, isCompatibilityEnabled() ? 'UPLOADED. CHECKING COMPATIBILITY...' : 'UPLOADED. PREPARING IMPORT...');
                try {
                    if (existingEntries.length) {
                        await pruneUploadJob(job, existingEntries.map((entry) => getEntryPath(entry)));
                        const compatibilityResult = await ensureCompatibilityBeforeImport(job, existingEntries);
                        if (compatibilityResult.proceed) {
                            registerImportJob(job);
                            setStatus('Import resumed. Files will appear in OMERO soon.', 'success');
                            delete window.pendingImportJob;
                            window.pendingImportFiles = [];
                        } else {
                            window.pendingImportFiles = existingEntries;
                            pendingFiles = [...existingEntries, ...newEntries];
                            refreshFileList();
                            shouldContinue = false;
                        }
                    } else {
                        delete window.pendingImportJob;
                        window.pendingImportFiles = [];
                    }

                    if (shouldContinue && newEntries.length) {
                        pendingFiles = newEntries;
                        expandedNodes.clear();
                        refreshFileList();
                        uploadTotalBytes = getPendingTotalBytes();
                        updateUploadOverlayProgress();

                        const newJob = await startUploadJob(pendingFiles);
                        uploadTotalBytes = newJob.totalBytes || uploadTotalBytes;
                        updateUploadOverlayProgress();
                        await uploadFiles(newJob.upload_url, pendingFiles);

                        const uploadedNewFiles = [...pendingFiles];
                        pendingFiles = [];
                        expandedNodes.clear();
                        fileInput.value = '';
                        folderInput.value = '';
                        refreshFileList();

                        const compatibilityResult = await ensureCompatibilityBeforeImport(newJob, uploadedNewFiles);
                        if (compatibilityResult.proceed) {
                            registerImportJob(newJob);
                            setStatus(
                                'Upload complete. You can close this browser window and log off. Files will appear in OMERO soon, if compatible.',
                                'success'
                            );
                        }
                    } else if (shouldContinue) {
                        pendingFiles = [];
                        expandedNodes.clear();
                        fileInput.value = '';
                        folderInput.value = '';
                        refreshFileList();
                    }
                } catch (error) {
                    setStatus(`Import failed: ${error.message || error}`, 'error');
                } finally {
                    setUploadingState(false);
                }
                updateUploadButtonLabel();
                return;
            }

            setUploadingState(true, 'UPLOADING');
            cancelUploadRequested = false;
            setStatus('');
            uploadTotalBytes = getPendingTotalBytes();
            updateUploadOverlayProgress();

            let job = null;
            let uploadedFiles = [];
            try {
                job = await startUploadJob();
                uploadTotalBytes = job.totalBytes || uploadTotalBytes;
                updateUploadOverlayProgress();
                await uploadFiles(job.upload_url);
                uploadedFiles = [...pendingFiles];
                pendingFiles = [];
                expandedNodes.clear();
                fileInput.value = '';
                folderInput.value = '';
                refreshFileList();
            } catch (error) {
                if (cancelUploadRequested) {
                    setStatus('Upload canceled. You can start a new upload when ready.', 'success');
                } else {
                    setStatus(`Upload failed: ${error.message || error}`, 'error');
                }
                setUploadingState(false);
                cancelUploadRequested = false;
                return;
            }
            
            if (job) {
                setUploadingState(true, isCompatibilityEnabled() ? 'UPLOADED. CHECKING COMPATIBILITY...' : 'UPLOADED. PREPARING IMPORT...');
                try {
                    const compatibilityResult = await ensureCompatibilityBeforeImport(job, uploadedFiles);
                    if (compatibilityResult.proceed) {
                        registerImportJob(job);
                        setStatus(
                            'Upload complete. You can close this browser window and log off. Files will appear in OMERO soon, if compatible.',
                            'success'
                        );
                    }
                } catch (error) {
                    setStatus(`Compatibility check failed: ${error.message || error}`, 'error');
                } finally {
                    setUploadingState(false);
                }
            } else {
                setUploadingState(false);
            }
        });

        cancelUploadBtn.addEventListener('click', () => {
            if (!isUploading) {
                return;
            }
            cancelUploadRequested = true;
            activeUploadRequests.forEach((xhr) => {
                try {
                    xhr.abort();
                } catch (error) {
                    // Ignore abort failures.
                }
            });
            activeUploadRequests.clear();
            setUploadingState(false);
            setStatus('Upload canceled. You can start a new upload when ready.', 'success');
        });

        if (projectSelectInput) {
            // Block drag propagation to prevent flickering and unintended focus shifts
            ['dragenter', 'dragover'].forEach(eventName => {
                projectSelectInput.addEventListener(eventName, (e) => e.stopPropagation());
            });

            projectSelectInput.addEventListener('focus', () => {
                if (isUploading) return; // Prevent expansion while uploading
                if (suppressProjectDropdownOpenOnFocusOnce) {
                    suppressProjectDropdownOpenOnFocusOnce = false;
                    return;
                }
                openProjectDropdown();
            });
            projectSelectInput.addEventListener('click', () => {
                if (isUploading) return; // Guard click event
                if (projectSelectDropdown?.style.display !== 'block') {
                    openProjectDropdown();
                }
            });
            projectSelectInput.addEventListener('input', (event) => {
                if (isUploading) return;
                filterProjectOptions(event.target.value);
            });
            projectSelectInput.addEventListener('keydown', (event) => {
                if (isUploading) return;
                if (projectSelectDropdown?.style.display !== 'block') return;
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    event.preventDefault();
                    const options = getProjectOptions();
                    if (options.length === 0) return;
                    const maxIndex = options.length - 1;
                    if (activeProjectIndex === -1) {
                        const nextIndex = event.key === 'ArrowDown' ? 0 : maxIndex;
                        setActiveProjectIndex(nextIndex, true);
                        return;
                    }
                    const delta = event.key === 'ArrowDown' ? 1 : -1;
                    const nextIndex = Math.max(0, Math.min(activeProjectIndex + delta, maxIndex));
                    setActiveProjectIndex(nextIndex, true);
                } else if (event.key === 'Enter') {
                    const options = getProjectOptions();
                    if (options.length === 0 || activeProjectIndex === -1) return;
                    event.preventDefault();
                    selectProjectOption(options[activeProjectIndex]);
                }
            });
        }

        if (specialUploadInput) {
            // Block drag propagation to prevent flickering and unintended focus shifts
            ['dragenter', 'dragover'].forEach(eventName => {
                specialUploadInput.addEventListener(eventName, (e) => e.stopPropagation());
            });

            specialUploadInput.addEventListener('focus', () => {
                if (isUploading) return; // Prevent expansion while uploading
                if (suppressSpecialUploadDropdownOpenOnFocusOnce) {
                    suppressSpecialUploadDropdownOpenOnFocusOnce = false;
                    return;
                }
                openSpecialUploadDropdown();
            });
            specialUploadInput.addEventListener('click', () => {
                if (isUploading) return; // Guard click event
                if (specialUploadDropdown?.style.display !== 'block') {
                    openSpecialUploadDropdown();
                }
            });
            specialUploadInput.addEventListener('input', (event) => {
                if (isUploading) return;
                filterSpecialUploadOptions(event.target.value);
            });
            specialUploadInput.addEventListener('keydown', (event) => {
                if (isUploading) return;
                if (specialUploadDropdown?.style.display !== 'block') return;
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    event.preventDefault();
                    const options = getSpecialUploadOptionElements();
                    if (options.length === 0) return;
                    const maxIndex = options.length - 1;
                    if (activeSpecialUploadIndex === -1) {
                        const nextIndex = event.key === 'ArrowDown' ? 0 : maxIndex;
                        setActiveSpecialUploadIndex(nextIndex, true);
                        return;
                    }
                    const delta = event.key === 'ArrowDown' ? 1 : -1;
                    const nextIndex = Math.max(0, Math.min(activeSpecialUploadIndex + delta, maxIndex));
                    setActiveSpecialUploadIndex(nextIndex, true);
                } else if (event.key === 'Enter') {
                    const options = getSpecialUploadOptionElements();
                    if (options.length === 0 || activeSpecialUploadIndex === -1) return;
                    event.preventDefault();
                    selectSpecialUploadOption(options[activeSpecialUploadIndex]);
                }
            });
        }

        
        if (collaborationToggle) {
            collaborationToggle.addEventListener('change', () => {
                applyCollaborationState(collaborationToggle.checked, { persist: true, refresh: true });
            });
        }

        if (compatibilityToggle) {
            compatibilityToggle.addEventListener('change', () => {
                applyCompatibilityState(compatibilityToggle.checked);
            });
        }

        if (projectRefreshBtn) {
            projectRefreshBtn.addEventListener('click', () => {
                refreshProjectList();
            });
        }

        if (projectSelectDropdown) {
            projectSelectDropdown.addEventListener('click', (event) => {
                const option = event.target.closest('.project-option');
                if (!option) return;
                selectProjectOption(option);
            });

            projectSelectDropdown.addEventListener('mousemove', (event) => {
                const option = event.target.closest('.project-option');
                if (!option) return;
                const options = getProjectOptions();
                const index = options.indexOf(option);
                if (index !== -1) {
                    setActiveProjectIndex(index, false);
                }
            });
        }

        if (specialUploadDropdown) {
            specialUploadDropdown.addEventListener('click', (event) => {
                const option = event.target.closest('.project-option');
                if (!option) return;
                selectSpecialUploadOption(option);
            });

            specialUploadDropdown.addEventListener('mousemove', (event) => {
                const option = event.target.closest('.project-option');
                if (!option) return;
                const options = getSpecialUploadOptionElements();
                const index = options.indexOf(option);
                if (index !== -1) {
                    setActiveSpecialUploadIndex(index, false);
                }
            });
        }

        if (nextStepBtn) {
            nextStepBtn.addEventListener('click', async () => {
                if (!isSemEdxSelected()) return;
                if (semEdxInstructionStep <= 1) {
                    setSemEdxInstructionsStep(2);
                    updateSemEdxStatus();
                    return;
                }

                if (semEdxInstructionStep === 2) {
                    if (semEdxAssociationMode !== 'manual') {
                        await ensureSemEdxAutomaticAssociations();
                    }

                    if (!updateSemEdxStatus()) {
                        return;
                    }

                    const appendedCount = getSemEdxAppendedCount();
                    if (appendedCount < 1) {
                        updateSemEdxStatus();
                        return;
                    }

                    if (semEdxSettingsDraft) {
                        applySemEdxSettings(semEdxSettingsDraft);
                    } else {
                        const loadedSettings = await ensureSpecialMethodSettingsLoaded(
                            'sem_edx_spectra',
                            semEdxSettingsDefaults,
                            applySemEdxSettings
                        );
                        semEdxSettingsDraft = loadedSettings;
                    }
                    setSemEdxInstructionsStep(3);
                    updateSemEdxStatus();
                    return;
                }

                if (!updateSemEdxStatus()) {
                    return;
                }

                const appendedCount = getSemEdxAppendedCount();
                if (appendedCount < 1) {
                    updateSemEdxStatus();
                    return;
                }

                const proceed = await showSemEdxConfirmPopup(
                    'Are you sure you want to proceed with Upload & Import? The selected SEM images will be imported into OMERO and the associated spectra will be appended.'
                );
                if (proceed) {
                    uploadBtn?.click();
                }
            });
        }

        if (previousStepBtn) {
            previousStepBtn.addEventListener('click', () => {
                if (!isSemEdxSelected()) return;
                const nextStep = Math.max(1, semEdxInstructionStep - 1);
                setSemEdxInstructionsStep(nextStep);
                updateSemEdxStatus();
            });
        }

        if (projectDropdownBackdrop) {
            projectDropdownBackdrop.addEventListener('click', (event) => {
                // Don't close if clicking the refresh button or collaboration toggle
                if ((projectRefreshBtn && (event.target === projectRefreshBtn || projectRefreshBtn.contains(event.target))) ||
                    (collaborationSection && collaborationSection.contains(event.target))) {
                    return;
                }
                closeProjectDropdown(true);
                closeSpecialUploadDropdown(true);
            });
        }

        if (settingsMenuBtn) {
            settingsMenuBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                const shouldShow = settingsMenu?.style.display !== 'block';
                showSettingsMenu(shouldShow);
            });
        }

        document.addEventListener('click', (event) => {
            if (!settingsMenu) return;
            if (settingsMenu.contains(event.target) || settingsMenuBtn?.contains(event.target)) {
                return;
            }
            showSettingsMenu(false);
        });

        if (userSettingsBtn) {
            userSettingsBtn.addEventListener('click', () => {
                showSettingsMenu(false);
                populateUserSettings();
                openUserSettingsModal();
            });
        }

        if (userSettingsClose) {
            userSettingsClose.addEventListener('click', closeUserSettingsModal);
        }

        if (userSettingsSave) {
            userSettingsSave.addEventListener('click', () => {
                clearUserSettingErrors();
                const validated = validateUserSettings();
                if (!validated) return;

                closeUserSettingsModal();

                saveUserSettingsToDatabase(validated, {
                    onSuccess: (data) => {
                        if (data && data.success === true && data.settings) {
                            applyUserSettings(data.settings);

                            if (storage) {
                                try {
                                    storage.setItem(userSettingsStorageKey, JSON.stringify(data.settings));
                                } catch (error) {
                                    // Ignore storage failures.
                                }
                            }
                        }
                    },
                });
            });
        }
        if (userSettingsRestore) {
            userSettingsRestore.addEventListener('click', () => {
                if (!window.confirm(messages.confirmIrreversible)) {
                    return;
                }
                if (storage) {
                    try {
                        storage.removeItem(userSettingsStorageKey);
                    } catch (error) {
                        // Ignore storage failures.
                    }
                }
                resetUserSettingsToDefaults();
            });
        }

        if (semEdxSettingsSave) {
            semEdxSettingsSave.addEventListener('click', () => {
                if (!isSemEdxSelected()) {
                    return;
                }
                const settings = getSemEdxSettingsPayload();
                saveSpecialMethodSettingsToDatabase('sem_edx_spectra', settings);
            });
        }
        if (semEdxSettingTables) {
            semEdxSettingTables.addEventListener('change', syncSemEdxSettingsDraft);
        }
        if (semEdxSettingFiguresAttachment) {
            semEdxSettingFiguresAttachment.addEventListener('change', syncSemEdxSettingsDraft);
        }
        if (semEdxSettingFiguresImage) {
            semEdxSettingFiguresImage.addEventListener('change', syncSemEdxSettingsDraft);
        }

        const storedCompatibilityState = loadCompatibilityState();
        if (storedCompatibilityState !== null) {
            applyCompatibilityState(storedCompatibilityState);
        }

        if (userSettingsBatchInput) {
            userSettingsBatchInput.addEventListener('input', () => {
                setUserSettingError(userSettingsBatchInput, false);
                setUserSettingsStatus('');
            });
        }

        if (clearAllBtn) {
            clearAllBtn.addEventListener('click', () => {
                clearSelectedFiles();
                clearProjectSelection();
                clearSpecialUploadSelection();
                if (!isUploading && !hasActiveImport()) {
                    clearImportState();
                    setStatus('');
                }
            });
        }

        if (!uploadEnabled) {
            setStatus('Upload folder is not writable. Please contact the server administrator.', 'error');
        }
        applyUserSettings(loadUserSettings() || userSettingsDefaults);
        const storedCollaborationState = loadCollaborationState();
        if (storedCollaborationState !== null && updateCollaborationVisibility()) {
            applyCollaborationState(storedCollaborationState, { persist: false, refresh: false });
        }
        restoreProjectSelection();
        restoreSpecialUploadSelection();
        restoreImportState();
        if (importJobs.size) {
            updateProgressFromJobs();
            ensureImportPolling();
        }
        updateUploadButtonLabel();
        updateCancelButtons();
    </script>
</body>
</html>
